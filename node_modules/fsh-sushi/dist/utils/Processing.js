"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const readline_sync_1 = __importDefault(require("readline-sync"));
const FSHLogger_1 = require("./FSHLogger");
const load_1 = require("../fhirdefs/load");
const import_1 = require("../import");
const lodash_1 = require("lodash");
const yaml_1 = __importDefault(require("yaml"));
const InstanceDefinitionUtils_1 = require("./InstanceDefinitionUtils");
const loadConfigurationFromIgResource_1 = require("../import/loadConfigurationFromIgResource");
function isSupportedFHIRVersion(version) {
    // For now, allow current or any 4.x version of FHIR except 4.0.0. This is a quick check; not a guarantee.  If a user passes
    // in an invalid version that passes this test (e.g., 4.99.0), it is still expected to fail when we load dependencies.
    return /current|4\.0\.1|4\.[1-9]\d*.\d+/.test(version);
}
exports.isSupportedFHIRVersion = isSupportedFHIRVersion;
function ensureInputDir(input) {
    // If no input folder is specified, set default to current directory
    if (!input) {
        input = '.';
        FSHLogger_1.logger.info('path-to-fsh-defs defaulted to current working directory');
    }
    return input;
}
exports.ensureInputDir = ensureInputDir;
function hasFshFiles(path) {
    try {
        const files = getFilesRecursive(path).filter(file => file.endsWith('.fsh'));
        return files.length > 0;
    }
    catch (error) {
        return false;
    }
}
exports.hasFshFiles = hasFshFiles;
function findInputDir(input) {
    const originalInput = input;
    const inputFshSubdirectoryPath = path_1.default.join(originalInput, 'input', 'fsh');
    const fshSubdirectoryPath = path_1.default.join(originalInput, 'fsh');
    const rootIgDataPath = path_1.default.join(originalInput, 'ig-data');
    const currentTankWithNoFsh = !fs_extra_1.default.existsSync(inputFshSubdirectoryPath) &&
        !fs_extra_1.default.existsSync(fshSubdirectoryPath) &&
        !fs_extra_1.default.existsSync(rootIgDataPath) &&
        !hasFshFiles(originalInput);
    // Use input/fsh/ subdirectory if not already specified and present
    // or when in the current tank configuration without FSH files
    if (fs_extra_1.default.existsSync(inputFshSubdirectoryPath) || currentTankWithNoFsh) {
        input = path_1.default.join(originalInput, 'input', 'fsh');
    }
    // TODO: Legacy support. Remove when no longer supported.
    // Use fsh/ subdirectory if not already specified and present
    if (!fs_extra_1.default.existsSync(inputFshSubdirectoryPath) && !currentTankWithNoFsh) {
        let msg = '\n\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! IMPORTANT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n';
        if (fs_extra_1.default.existsSync(fshSubdirectoryPath)) {
            input = path_1.default.join(input, 'fsh');
            msg +=
                '\nSUSHI detected a "fsh" directory that will be used in the input path.\n' +
                    'Use of this folder is DEPRECATED and will be REMOVED in a future release.\n' +
                    'To migrate to the new folder structure, make the following changes:\n' +
                    `  - move fsh${path_1.default.sep}config.yaml to .${path_1.default.sep}sushi-config.yaml\n` +
                    `  - move fsh${path_1.default.sep}*.fsh files to .${path_1.default.sep}input${path_1.default.sep}fsh${path_1.default.sep}*.fsh\n`;
            if (fs_extra_1.default.existsSync(path_1.default.join(input, 'ig-data'))) {
                msg += `  - move fsh${path_1.default.sep}ig-data${path_1.default.sep}* files and folders to .${path_1.default.sep}*\n`;
            }
        }
        else {
            msg +=
                '\nSUSHI has adopted a new folder structure for FSH tanks (a.k.a. SUSHI projects).\n' +
                    'Support for other folder structures is DEPRECATED and will be REMOVED in a future release.\n' +
                    'To migrate to the new folder structure, make the following changes:\n' +
                    `  - rename .${path_1.default.sep}config.yaml to .${path_1.default.sep}sushi-config.yaml\n` +
                    `  - move .${path_1.default.sep}*.fsh files to .${path_1.default.sep}input${path_1.default.sep}fsh${path_1.default.sep}*.fsh\n`;
            if (fs_extra_1.default.existsSync(path_1.default.join(input, 'ig-data'))) {
                msg += `  - move .${path_1.default.sep}ig-data${path_1.default.sep}* files and folders to .${path_1.default.sep}*\n`;
            }
        }
        if (!fs_extra_1.default.existsSync(path_1.default.join(input, 'ig-data', 'ig.ini'))) {
            msg += `  - if you used the "template" property in your config, remove it and manage .${path_1.default.sep}ig.ini directly\n`;
        }
        if (!fs_extra_1.default.existsSync(path_1.default.join(input, 'ig-data', 'package-list.json'))) {
            msg += `  - if you used the "history" property in your config, remove it and manage .${path_1.default.sep}package-list.json directly\n`;
        }
        msg +=
            '  - ensure your .gitignore file is not configured to ignore the sources in their new locations\n' +
                '  - add /fsh-generated to your .gitignore file to prevent SUSHI output from being checked into source control\n\n' +
                `NOTE: After you make these changes, the default ouput folder for SUSHI will change to .${path_1.default.sep}fsh-generated.\n\n` +
                'For detailed migration instructions, see: https://fshschool.org/docs/sushi/migration/\n\n';
        FSHLogger_1.logger.warn(msg);
    }
    return input;
}
exports.findInputDir = findInputDir;
function ensureOutputDir(input, output, isIgPubContext, isLegacyIgPubContext) {
    let outDir = output;
    if (isLegacyIgPubContext && !output) {
        // TODO: Legacy support for top level "fsh" directory. Remove when no longer supported.
        // When running in a legacy IG Publisher context, default output is the parent folder of the tank
        outDir = path_1.default.join(input, '..');
        FSHLogger_1.logger.info(`No output path specified. Output to ${outDir}`);
    }
    else if (isIgPubContext && !output) {
        // When running in an IG Publisher context, default output is the parent folder of the input/fsh folder
        outDir = path_1.default.join(input, '..', '..');
        FSHLogger_1.logger.info(`No output path specified. Output to ${outDir}`);
    }
    else if (!output) {
        // Any other time, default output is just to 'build'
        outDir = path_1.default.join('.', 'build');
        FSHLogger_1.logger.info(`No output path specified. Output to ${outDir}`);
    }
    fs_extra_1.default.ensureDirSync(outDir);
    // If the outDir contains a fsh-generated folder, we ensure that folder is empty
    const fshGeneratedFolder = path_1.default.join(outDir, 'fsh-generated');
    if (fs_extra_1.default.existsSync(fshGeneratedFolder)) {
        try {
            fs_extra_1.default.emptyDirSync(fshGeneratedFolder);
        }
        catch (e) {
            FSHLogger_1.logger.error(`Unable to empty existing fsh-generated folder because of the following error: ${e.message}`);
        }
    }
    return outDir;
}
exports.ensureOutputDir = ensureOutputDir;
function readConfig(input, isLegacyIgPubContext) {
    const configPath = import_1.ensureConfiguration(input);
    let config;
    if (configPath == null || !fs_extra_1.default.existsSync(configPath)) {
        config = loadConfigurationFromIgResource_1.loadConfigurationFromIgResource(isLegacyIgPubContext ? path_1.default.dirname(input) : input);
    }
    else {
        const configYaml = fs_extra_1.default.readFileSync(configPath, 'utf8');
        config = import_1.importConfiguration(configYaml, configPath);
    }
    if (!config) {
        FSHLogger_1.logger.error(`No sushi-config.yaml in ${input} folder, and no configuration could` +
            ' be extracted from an ImplementationGuide resource.');
        throw Error;
    }
    if (!config.fhirVersion.some(v => isSupportedFHIRVersion(v))) {
        FSHLogger_1.logger.error(`The ${path_1.default.basename(config.filePath)} must specify a supported version of FHIR. Be sure to` +
            ` add "fhirVersion: 4.0.1" (or 4.x.y, as appropriate) to the ${path_1.default.basename(config.filePath)} file.`);
        throw Error;
    }
    return config;
}
exports.readConfig = readConfig;
function loadExternalDependencies(defs, config) {
    var _a, _b;
    // Add FHIR to the dependencies so it is loaded
    const dependencies = ((_a = config.dependencies) !== null && _a !== void 0 ? _a : []).slice(); // slice so we don't modify actual config;
    const fhirVersion = config.fhirVersion.find(v => isSupportedFHIRVersion(v));
    const fhirPackageId = fhirVersion.startsWith('4.0') ? 'hl7.fhir.r4.core' : 'hl7.fhir.r5.core';
    if (fhirPackageId === 'hl7.fhir.r5.core') {
        FSHLogger_1.logger.warn('SUSHI support for pre-release versions of FHIR is experimental. Use at your own risk!');
    }
    dependencies.push({ packageId: fhirPackageId, version: fhirVersion });
    // Load dependencies
    const dependencyDefs = [];
    for (const dep of dependencies) {
        if (dep.version == null) {
            FSHLogger_1.logger.error(`Failed to load ${dep.packageId}: No version specified. To specify the version in your ` +
                `${path_1.default.basename(config.filePath)}, either use the simple dependency format:\n\n` +
                'dependencies:\n' +
                `  ${dep.packageId}: current\n\n` +
                'or use the detailed dependency format to specify other properties as well:\n\n' +
                'dependencies:\n' +
                `  ${dep.packageId}:\n` +
                `    uri: ${(_b = dep.uri) !== null && _b !== void 0 ? _b : 'http://my-fhir-ig.org/ImplementationGuide/123'}\n` +
                '    version: current');
            continue;
        }
        dependencyDefs.push(load_1.loadDependency(dep.packageId, dep.version, defs)
            .then(def => {
            return def;
        })
            .catch(e => {
            FSHLogger_1.logger.error(`Failed to load ${dep.packageId}#${dep.version}: ${e.message}`);
        }));
    }
    return dependencyDefs;
}
exports.loadExternalDependencies = loadExternalDependencies;
function getRawFSHes(input) {
    let files;
    try {
        files = getFilesRecursive(input);
    }
    catch (_a) {
        FSHLogger_1.logger.error('Invalid path to FSH definition folder.');
        throw Error;
    }
    const rawFSHes = files
        .filter(file => file.endsWith('.fsh'))
        .map(file => {
        const filePath = path_1.default.resolve(file);
        const fileContent = fs_extra_1.default.readFileSync(filePath, 'utf8');
        return new import_1.RawFSH(fileContent, filePath);
    });
    return rawFSHes;
}
exports.getRawFSHes = getRawFSHes;
function fillTank(rawFSHes, config) {
    FSHLogger_1.logger.info('Importing FSH text...');
    const docs = import_1.importText(rawFSHes);
    return new import_1.FSHTank(docs, config);
}
exports.fillTank = fillTank;
function writeFHIRResources(outDir, outPackage, defs, snapshot, isIgPubContext) {
    FSHLogger_1.logger.info('Exporting FHIR resources as JSON...');
    let count = 0;
    const predefinedResources = defs.allPredefinedResources();
    const writeResources = (folder, resources) => {
        const exportDir = isIgPubContext
            ? path_1.default.join(outDir, 'fsh-generated', 'resources')
            : path_1.default.join(outDir, 'input', folder);
        resources.forEach(resource => {
            var _a;
            if (!predefinedResources.find(predef => predef.url === resource.url &&
                predef.resourceType === resource.resourceType &&
                predef.id === resource.id)) {
                fs_extra_1.default.outputJSONSync(path_1.default.join(exportDir, resource.getFileName()), resource.toJSON(snapshot), {
                    spaces: 2
                });
                count++;
            }
            else {
                FSHLogger_1.logger.error(`Ignoring FSH definition for ${(_a = resource.url) !== null && _a !== void 0 ? _a : `${resource.resourceType}/${resource.id}`} since it duplicates existing pre-defined resource. ` +
                    'To use the FSH definition, remove the conflicting file from "input". ' +
                    'If you do want the FSH definition to be ignored, please comment the definition out ' +
                    'to remove this error.');
            }
        });
    };
    writeResources('profiles', outPackage.profiles);
    writeResources('extensions', outPackage.extensions);
    writeResources('vocabulary', [...outPackage.valueSets, ...outPackage.codeSystems]);
    // Sort instances into appropriate directories
    const instances = lodash_1.cloneDeep(outPackage.instances); // Filter functions below mutate the argument, so clone what is in the package
    InstanceDefinitionUtils_1.filterInlineInstances(instances);
    writeResources('examples', InstanceDefinitionUtils_1.filterExampleInstances(instances));
    writeResources('capabilities', InstanceDefinitionUtils_1.filterCapabilitiesInstances(instances));
    writeResources('vocabulary', InstanceDefinitionUtils_1.filterVocabularyInstances(instances));
    writeResources('models', InstanceDefinitionUtils_1.filterModelInstances(instances));
    writeResources('operations', InstanceDefinitionUtils_1.filterOperationInstances(instances));
    writeResources('extensions', InstanceDefinitionUtils_1.filterExtensionInstances(instances));
    writeResources('profiles', InstanceDefinitionUtils_1.filterProfileInstances(instances));
    writeResources('resources', instances); // Any instance left cannot be categorized any further so should just be in generic resources
    FSHLogger_1.logger.info(`Exported ${count} FHIR resources as JSON.`);
}
exports.writeFHIRResources = writeFHIRResources;
/**
 * Initializes an empty sample FSH within a user specified subdirectory of the current working directory
 */
function init() {
    return __awaiter(this, void 0, void 0, function* () {
        console.log('\n╭──────────────────────────────────────────────────────────╮\n' +
            '│ This interactive tool will use your answers to create a  │\n' +
            "│ working SUSHI project configured with your project's     │\n" +
            '│ basic information.                                       │\n' +
            '╰──────────────────────────────────────────────────────────╯\n');
        const configDoc = yaml_1.default.parseDocument(fs_extra_1.default.readFileSync(path_1.default.join(__dirname, 'init-project', 'sushi-config.yaml'), 'utf-8'));
        // Accept user input for certain fields
        ['name', 'id', 'canonical', 'status', 'version'].forEach(field => {
            const userValue = readline_sync_1.default.question(`${field.charAt(0).toUpperCase() + field.slice(1)} (Default: ${configDoc.get(field)}): `);
            if (userValue) {
                configDoc.set(field, userValue);
            }
        });
        // Ensure copyrightYear is accurate
        configDoc.set('copyrightYear', `${new Date().getFullYear()}+`);
        const projectName = configDoc.get('name');
        // Write init directory out, including user made sushi-config.yaml, files in utils/init-project, and build scripts from ig/files
        const outputDir = path_1.default.resolve('.', projectName);
        const initProjectDir = path_1.default.join(__dirname, 'init-project');
        if (!readline_sync_1.default.keyInYN(`Initialize SUSHI project in ${outputDir}?`)) {
            console.log('\nAborting Initialization.\n');
            return;
        }
        // Add index.md content, updating to reflect the user given name
        const indexPageContent = fs_extra_1.default
            .readFileSync(path_1.default.join(initProjectDir, 'index.md'), 'utf-8')
            .replace('ExampleIG', projectName);
        fs_extra_1.default.ensureDirSync(path_1.default.join(outputDir, 'input', 'pagecontent'));
        fs_extra_1.default.writeFileSync(path_1.default.join(outputDir, 'input', 'pagecontent', 'index.md'), indexPageContent);
        // Add ig.ini, updating to reflect the user given id
        const iniContent = fs_extra_1.default
            .readFileSync(path_1.default.join(initProjectDir, 'ig.ini'), 'utf-8')
            .replace('fhir.example', configDoc.get('id'));
        fs_extra_1.default.writeFileSync(path_1.default.join(outputDir, 'ig.ini'), iniContent);
        // Add the config
        fs_extra_1.default.writeFileSync(path_1.default.join(outputDir, 'sushi-config.yaml'), configDoc.toString());
        // Copy over remaining static files
        fs_extra_1.default.ensureDirSync(path_1.default.join(outputDir, 'input', 'fsh'));
        fs_extra_1.default.copyFileSync(path_1.default.join(initProjectDir, 'patient.fsh'), path_1.default.join(outputDir, 'input', 'fsh', 'patient.fsh'));
        fs_extra_1.default.copyFileSync(path_1.default.join(initProjectDir, 'init-gitignore.txt'), path_1.default.join(outputDir, '.gitignore'));
        fs_extra_1.default.copyFileSync(path_1.default.join(initProjectDir, 'ignoreWarnings.txt'), path_1.default.join(outputDir, 'input', 'ignoreWarnings.txt'));
        // Add the _updatePublisher, _genonce, and _gencontinuous scripts
        console.log('Downloading publisher scripts from https://github.com/HL7/ig-publisher-scripts');
        for (const script of [
            '_genonce.bat',
            '_genonce.sh',
            '_updatePublisher.bat',
            '_updatePublisher.sh'
        ]) {
            const url = `http://raw.githubusercontent.com/HL7/ig-publisher-scripts/main/${script}`;
            try {
                const res = yield axios_1.default.get(url);
                fs_extra_1.default.writeFileSync(path_1.default.join(outputDir, script), res.data);
                if (script.endsWith('.sh')) {
                    fs_extra_1.default.chmodSync(path_1.default.join(outputDir, script), 0o755);
                }
            }
            catch (e) {
                FSHLogger_1.logger.error(`Unable to download ${script} from ${url}: ${e.message}`);
            }
        }
        const maxLength = 31;
        const printName = projectName.length > maxLength ? projectName.slice(0, maxLength - 3) + '...' : projectName;
        console.log('\n╭──────────────────────────────────────────────────────────╮\n' +
            `│ Project initialized at: ./${lodash_1.padEnd(printName, maxLength)}│\n` +
            '├──────────────────────────────────────────────────────────┤\n' +
            '│ Now try this:                                            │\n' +
            '│                                                          │\n' +
            `│ > cd ${lodash_1.padEnd(printName, maxLength + 21)}│\n` +
            '│ > sushi .                                                │\n' +
            '│                                                          │\n' +
            '│ For guidance on project structure and configuration see  │\n' +
            '│ the SUSHI documentation:  https://fshschool.org/sushi    │\n' +
            '╰──────────────────────────────────────────────────────────╯\n');
    });
}
exports.init = init;
function getFilesRecursive(dir) {
    if (fs_extra_1.default.statSync(dir).isDirectory()) {
        const ancestors = fs_extra_1.default.readdirSync(dir, 'utf8').map(f => getFilesRecursive(path_1.default.join(dir, f)));
        return [].concat(...ancestors);
    }
    else {
        return [dir];
    }
}
//# sourceMappingURL=Processing.js.map