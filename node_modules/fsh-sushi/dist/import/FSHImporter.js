"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const FSHDocument_1 = require("./FSHDocument");
const FSHErrorListener_1 = require("./FSHErrorListener");
const FSHVisitor_1 = require("./generated/FSHVisitor");
const FSHLexer_1 = require("./generated/FSHLexer");
const FSHParser_1 = require("./generated/FSHParser");
const fshtypes_1 = require("../fshtypes");
const rules_1 = require("../fshtypes/rules");
const antlr4_1 = require("antlr4");
const FSHLogger_1 = require("../utils/FSHLogger");
const Tree_1 = require("antlr4/tree/Tree");
const errors_1 = require("../errors");
const isEqual_1 = __importDefault(require("lodash/isEqual"));
const sortBy_1 = __importDefault(require("lodash/sortBy"));
const upperFirst_1 = __importDefault(require("lodash/upperFirst"));
const min_1 = __importDefault(require("lodash/min"));
const parseCodeLexeme_1 = require("./parseCodeLexeme");
const os_1 = require("os");
var SdMetadataKey;
(function (SdMetadataKey) {
    SdMetadataKey["Id"] = "Id";
    SdMetadataKey["Parent"] = "Parent";
    SdMetadataKey["Title"] = "Title";
    SdMetadataKey["Description"] = "Description";
    SdMetadataKey["Mixins"] = "Mixins";
    SdMetadataKey["Unknown"] = "Unknown";
})(SdMetadataKey || (SdMetadataKey = {}));
var InstanceMetadataKey;
(function (InstanceMetadataKey) {
    InstanceMetadataKey["InstanceOf"] = "InstanceOf";
    InstanceMetadataKey["Title"] = "Title";
    InstanceMetadataKey["Description"] = "Description";
    InstanceMetadataKey["Usage"] = "Usage";
    InstanceMetadataKey["Mixins"] = "Mixins";
    InstanceMetadataKey["Unknown"] = "Unknown";
})(InstanceMetadataKey || (InstanceMetadataKey = {}));
var VsMetadataKey;
(function (VsMetadataKey) {
    VsMetadataKey["Id"] = "Id";
    VsMetadataKey["Title"] = "Title";
    VsMetadataKey["Description"] = "Description";
    VsMetadataKey["Unknown"] = "Unknown";
})(VsMetadataKey || (VsMetadataKey = {}));
var CsMetadataKey;
(function (CsMetadataKey) {
    CsMetadataKey["Id"] = "Id";
    CsMetadataKey["Title"] = "Title";
    CsMetadataKey["Description"] = "Description";
    CsMetadataKey["Unknown"] = "Unknown";
})(CsMetadataKey || (CsMetadataKey = {}));
var InvariantMetadataKey;
(function (InvariantMetadataKey) {
    InvariantMetadataKey["Description"] = "Description";
    InvariantMetadataKey["Expression"] = "Expression";
    InvariantMetadataKey["XPath"] = "XPath";
    InvariantMetadataKey["Severity"] = "Severity";
    InvariantMetadataKey["Unknown"] = "Unknown";
})(InvariantMetadataKey || (InvariantMetadataKey = {}));
var MappingMetadataKey;
(function (MappingMetadataKey) {
    MappingMetadataKey["Id"] = "Id";
    MappingMetadataKey["Source"] = "Source";
    MappingMetadataKey["Target"] = "Target";
    MappingMetadataKey["Description"] = "Description";
    MappingMetadataKey["Title"] = "Title";
    MappingMetadataKey["Unknown"] = "Unknown";
})(MappingMetadataKey || (MappingMetadataKey = {}));
var Flag;
(function (Flag) {
    Flag[Flag["MustSupport"] = 0] = "MustSupport";
    Flag[Flag["Summary"] = 1] = "Summary";
    Flag[Flag["Modifier"] = 2] = "Modifier";
    Flag[Flag["TrialUse"] = 3] = "TrialUse";
    Flag[Flag["Normative"] = 4] = "Normative";
    Flag[Flag["Draft"] = 5] = "Draft";
    Flag[Flag["Unknown"] = 6] = "Unknown";
})(Flag || (Flag = {}));
/**
 * FSHImporter handles the parsing of FSH documents, constructing the data into FSH types.
 * FSHImporter uses a visitor pattern approach with some accomodations due to the ANTLR4
 * implementation and TypeScript requirements.  For example, the `accept` functions that
 * each `ctx` has cannot be used because their signatures return `void` by default. Instead,
 * we must call the explicit visitX functions.
 */
class FSHImporter extends FSHVisitor_1.FSHVisitor {
    constructor() {
        super();
        this.paramRuleSets = new Map();
        this.topLevelParse = true;
    }
    import(rawFSHes) {
        this.allAliases = new Map();
        const docs = [];
        const contexts = [];
        // Preprocess the FSH files
        rawFSHes.forEach(rawFSH => {
            var _a;
            // Create and store doc for main import process
            const doc = new FSHDocument_1.FSHDocument(rawFSH.path);
            docs.push(doc);
            this.currentDoc = doc;
            this.currentFile = (_a = this.currentDoc.file) !== null && _a !== void 0 ? _a : '';
            // Create and store context for main import process
            // We are appending a newline to the file content if there is not one there already.
            // This is being done because we discovered a syntax error that occurs if a comments
            // ends a file, and there is no newline after it. Comments are only tokenized in our
            // grammar if a newline follows it. In order to prevent this error from occurring,
            // we add a newline to the content before we parse it so comments at EOF can be tokenized.
            const content = rawFSH.content.endsWith('\n') ? rawFSH.content : rawFSH.content + '\n';
            const ctx = this.parseDoc(content, rawFSH.path);
            contexts.push(ctx);
            // Collect the aliases and store in global map
            ctx.entity().forEach(e => {
                var _a, _b;
                if (e.alias()) {
                    const [name, value] = e
                        .alias()
                        .SEQUENCE()
                        .map(s => s.getText());
                    if (name.includes('|')) {
                        FSHLogger_1.logger.error(`Alias ${name} cannot include "|" since the "|" character is reserved for indicating a version`, { file: (_a = doc.file) !== null && _a !== void 0 ? _a : '', location: this.extractStartStop(e.alias()) });
                        return;
                    }
                    if (this.allAliases.has(name) && this.allAliases.get(name) !== value) {
                        FSHLogger_1.logger.error(`Alias ${name} cannot be redefined to ${value}; it is already defined as ${this.allAliases.get(name)}.`, { file: (_b = doc.file) !== null && _b !== void 0 ? _b : '', location: this.extractStartStop(e.alias()) });
                        // don't set it -- just keep the original definition
                    }
                    else {
                        this.allAliases.set(name, value);
                        doc.aliases.set(name, value);
                    }
                }
                if (e.paramRuleSet()) {
                    this.visitParamRuleSet(e.paramRuleSet());
                }
            });
            this.currentDoc = null;
            this.currentFile = null;
        });
        FSHLogger_1.logger.info(`Preprocessed ${docs.length} documents with ${this.allAliases.size} aliases.`);
        // Now do the main import
        contexts.forEach((context, index) => {
            var _a;
            this.currentDoc = docs[index];
            this.currentFile = (_a = this.currentDoc.file) !== null && _a !== void 0 ? _a : '';
            this.visitDoc(context);
            this.currentDoc = null;
            this.currentFile = null;
        });
        let [definitions, instances] = [0, 0];
        docs.forEach(doc => {
            definitions +=
                doc.codeSystems.size + doc.extensions.size + doc.profiles.size + doc.valueSets.size;
            instances += doc.instances.size;
        });
        FSHLogger_1.logger.info(`Imported ${definitions} definitions and ${instances} instances.`);
        return docs;
    }
    visitDoc(ctx) {
        ctx.entity().forEach(e => {
            try {
                this.visitEntity(e);
            }
            catch (err) {
                const sourceInfo = { location: this.extractStartStop(e), file: this.currentFile };
                FSHLogger_1.logger.error(`Error in parsing: ${err.message}`, sourceInfo);
            }
        });
    }
    visitEntity(ctx) {
        if (ctx.profile()) {
            this.visitProfile(ctx.profile());
        }
        if (ctx.extension()) {
            this.visitExtension(ctx.extension());
        }
        if (ctx.instance()) {
            this.visitInstance(ctx.instance());
        }
        if (ctx.valueSet()) {
            this.visitValueSet(ctx.valueSet());
        }
        if (ctx.codeSystem()) {
            this.visitCodeSystem(ctx.codeSystem());
        }
        if (ctx.invariant()) {
            this.visitInvariant(ctx.invariant());
        }
        if (ctx.ruleSet()) {
            this.visitRuleSet(ctx.ruleSet());
        }
        if (ctx.mapping()) {
            this.visitMapping(ctx.mapping());
        }
    }
    visitProfile(ctx) {
        const profile = new fshtypes_1.Profile(ctx.SEQUENCE().getText())
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        if (this.currentDoc.profiles.has(profile.name)) {
            FSHLogger_1.logger.error(`Skipping Profile: a Profile named ${profile.name} already exists.`, {
                file: this.currentFile,
                location: this.extractStartStop(ctx)
            });
        }
        else {
            this.parseProfileOrExtension(profile, ctx.sdMetadata(), ctx.sdRule());
            this.currentDoc.profiles.set(profile.name, profile);
        }
    }
    visitExtension(ctx) {
        const extension = new fshtypes_1.Extension(ctx.SEQUENCE().getText())
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        if (this.currentDoc.extensions.has(extension.name)) {
            FSHLogger_1.logger.error(`Skipping Extension: an Extension named ${extension.name} already exists.`, {
                file: this.currentFile,
                location: this.extractStartStop(ctx)
            });
        }
        else {
            this.parseProfileOrExtension(extension, ctx.sdMetadata(), ctx.sdRule());
            this.currentDoc.extensions.set(extension.name, extension);
        }
    }
    parseProfileOrExtension(def, metaCtx = [], ruleCtx = []) {
        const seenPairs = new Map();
        metaCtx
            .map(sdMeta => (Object.assign(Object.assign({}, this.visitSdMetadata(sdMeta)), { context: sdMeta })))
            .forEach(pair => {
            if (seenPairs.has(pair.key)) {
                FSHLogger_1.logger.error(`Metadata field '${pair.key}' already declared with value '${seenPairs.get(pair.key)}'.`, { file: this.currentFile, location: this.extractStartStop(pair.context) });
                return;
            }
            seenPairs.set(pair.key, pair.value);
            if (pair.key === SdMetadataKey.Id) {
                def.id = pair.value;
            }
            else if (pair.key === SdMetadataKey.Parent) {
                def.parent = pair.value;
            }
            else if (pair.key === SdMetadataKey.Title) {
                def.title = pair.value;
            }
            else if (pair.key === SdMetadataKey.Description) {
                def.description = pair.value;
            }
            else if (pair.key === SdMetadataKey.Mixins) {
                def.mixins = pair.value;
            }
        });
        ruleCtx.forEach(sdRule => {
            def.rules.push(...this.visitSdRule(sdRule));
        });
    }
    visitInstance(ctx) {
        const instance = new fshtypes_1.Instance(ctx.SEQUENCE().getText())
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        if (this.currentDoc.instances.has(instance.name)) {
            FSHLogger_1.logger.error(`Skipping Instance: an Instance named ${instance.name} already exists.`, {
                file: this.currentFile,
                location: this.extractStartStop(ctx)
            });
        }
        else {
            try {
                this.parseInstance(instance, ctx.instanceMetadata(), ctx.instanceRule());
                this.currentDoc.instances.set(instance.name, instance);
            }
            catch (e) {
                FSHLogger_1.logger.error(e.message, instance.sourceInfo);
            }
        }
    }
    parseInstance(instance, metaCtx = [], ruleCtx = []) {
        const seenPairs = new Map();
        metaCtx
            .map(instanceMetadata => (Object.assign(Object.assign({}, this.visitInstanceMetadata(instanceMetadata)), { context: instanceMetadata })))
            .forEach(pair => {
            if (seenPairs.has(pair.key)) {
                FSHLogger_1.logger.error(`Metadata field '${pair.key}' already declared with value '${seenPairs.get(pair.key)}'.`, { file: this.currentFile, location: this.extractStartStop(pair.context) });
                return;
            }
            seenPairs.set(pair.key, pair.value);
            if (pair.key === InstanceMetadataKey.InstanceOf) {
                instance.instanceOf = pair.value;
            }
            else if (pair.key === InstanceMetadataKey.Title) {
                instance.title = pair.value;
            }
            else if (pair.key === InstanceMetadataKey.Description) {
                instance.description = pair.value;
            }
            else if (pair.key === InstanceMetadataKey.Usage) {
                instance.usage = pair.value;
            }
            else if (pair.key === InstanceMetadataKey.Mixins) {
                instance.mixins = pair.value;
            }
        });
        if (!instance.instanceOf) {
            throw new errors_1.RequiredMetadataError('InstanceOf', 'Instance', instance.name);
        }
        ruleCtx.forEach(instanceRule => {
            const rule = this.visitInstanceRule(instanceRule);
            if (rule) {
                instance.rules.push(rule);
            }
        });
    }
    visitValueSet(ctx) {
        const valueSet = new fshtypes_1.FshValueSet(ctx.SEQUENCE().getText())
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        if (this.currentDoc.valueSets.has(valueSet.name)) {
            FSHLogger_1.logger.error(`Skipping ValueSet: a ValueSet named ${valueSet.name} already exists.`, {
                file: this.currentFile,
                location: this.extractStartStop(ctx)
            });
        }
        else {
            this.parseValueSet(valueSet, ctx.vsMetadata(), ctx.vsRule());
            this.currentDoc.valueSets.set(valueSet.name, valueSet);
        }
    }
    parseValueSet(valueSet, metaCtx = [], vsRuleCtx = []) {
        const seenPairs = new Map();
        metaCtx
            .map(vsMetadata => (Object.assign(Object.assign({}, this.visitVsMetadata(vsMetadata)), { context: vsMetadata })))
            .forEach(pair => {
            if (seenPairs.has(pair.key)) {
                FSHLogger_1.logger.error(`Metadata field '${pair.key}' already declared with value '${seenPairs.get(pair.key)}'.`, { file: this.currentFile, location: this.extractStartStop(pair.context) });
                return;
            }
            seenPairs.set(pair.key, pair.value);
            if (pair.key === VsMetadataKey.Id) {
                valueSet.id = pair.value;
            }
            else if (pair.key === VsMetadataKey.Title) {
                valueSet.title = pair.value;
            }
            else if (pair.key === VsMetadataKey.Description) {
                valueSet.description = pair.value;
            }
        });
        vsRuleCtx.forEach(vsRule => {
            const rule = this.visitVsRule(vsRule);
            // if rule is a concept component,
            // we may be able to merge its concepts into an existing concept component.
            if (rule instanceof rules_1.ValueSetConceptComponentRule) {
                const matchedComponent = valueSet.rules.find(existingComponent => {
                    return (existingComponent instanceof rules_1.ValueSetConceptComponentRule &&
                        rule.inclusion == existingComponent.inclusion &&
                        rule.from.system == existingComponent.from.system &&
                        isEqual_1.default(sortBy_1.default(rule.from.valueSets), sortBy_1.default(existingComponent.from.valueSets)));
                });
                if (matchedComponent) {
                    matchedComponent.concepts.push(...rule.concepts);
                }
                else {
                    valueSet.rules.push(rule);
                }
            }
            else if (rule) {
                valueSet.rules.push(rule);
            }
        });
    }
    visitCodeSystem(ctx) {
        const codeSystem = new fshtypes_1.FshCodeSystem(ctx.SEQUENCE().getText())
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        if (this.currentDoc.codeSystems.has(codeSystem.name)) {
            FSHLogger_1.logger.error(`Skipping code system: a code system named ${codeSystem.name} already exists.`, {
                file: this.currentFile,
                location: this.extractStartStop(ctx)
            });
        }
        else {
            this.parseCodeSystem(codeSystem, ctx.csMetadata(), ctx.csRule());
            this.currentDoc.codeSystems.set(codeSystem.name, codeSystem);
        }
    }
    parseCodeSystem(codeSystem, metaCtx = [], csRuleCtx = []) {
        const seenPairs = new Map();
        metaCtx
            .map(csMetadata => (Object.assign(Object.assign({}, this.visitCsMetadata(csMetadata)), { context: csMetadata })))
            .forEach(pair => {
            if (seenPairs.has(pair.key)) {
                FSHLogger_1.logger.error(`Metadata field '${pair.key}' already declared with value '${seenPairs.get(pair.key)}'.`, { file: this.currentFile, location: this.extractStartStop(pair.context) });
                return;
            }
            seenPairs.set(pair.key, pair.value);
            if (pair.key === CsMetadataKey.Id) {
                codeSystem.id = pair.value;
            }
            else if (pair.key === CsMetadataKey.Title) {
                codeSystem.title = pair.value;
            }
            else if (pair.key === CsMetadataKey.Description) {
                codeSystem.description = pair.value;
            }
        });
        csRuleCtx.forEach(ruleCtx => {
            const rule = this.visitCsRule(ruleCtx);
            if (rule instanceof rules_1.ConceptRule) {
                try {
                    codeSystem.addConcept(rule);
                }
                catch (e) {
                    FSHLogger_1.logger.error(e.message, rule.sourceInfo);
                }
            }
            else if (rule) {
                codeSystem.rules.push(rule);
            }
        });
    }
    visitInvariant(ctx) {
        const invariant = new fshtypes_1.Invariant(ctx.SEQUENCE().getText())
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        if (this.currentDoc.invariants.has(invariant.name)) {
            FSHLogger_1.logger.error(`Skipping Invariant: an Invariant named ${invariant.name} already exists.`, {
                file: this.currentFile,
                location: this.extractStartStop(ctx)
            });
        }
        else {
            this.parseInvariant(invariant, ctx.invariantMetadata());
            if (invariant.description == null) {
                FSHLogger_1.logger.error(`Invariant ${invariant.name} must have a Description.`, invariant.sourceInfo);
            }
            if (invariant.severity == null) {
                FSHLogger_1.logger.error(`Invariant ${invariant.name} must have a Severity.`, invariant.sourceInfo);
            }
            this.currentDoc.invariants.set(invariant.name, invariant);
        }
    }
    parseInvariant(invariant, metaCtx = []) {
        const seenPairs = new Map();
        metaCtx
            .map(invariantMetadata => (Object.assign(Object.assign({}, this.visitInvariantMetadata(invariantMetadata)), { context: invariantMetadata })))
            .forEach(pair => {
            if (seenPairs.has(pair.key)) {
                FSHLogger_1.logger.error(`Metadata field '${pair.key}' already declared with value '${seenPairs.get(pair.key)}'.`, { file: this.currentFile, location: this.extractStartStop(pair.context) });
                return;
            }
            seenPairs.set(pair.key, pair.value);
            if (pair.key === InvariantMetadataKey.Description) {
                invariant.description = pair.value;
            }
            else if (pair.key === InvariantMetadataKey.Expression) {
                invariant.expression = pair.value;
            }
            else if (pair.key === InvariantMetadataKey.Severity) {
                invariant.severity = pair.value;
            }
            else if (pair.key === InvariantMetadataKey.XPath) {
                invariant.xpath = pair.value;
            }
        });
    }
    visitRuleSet(ctx) {
        const ruleSet = new fshtypes_1.RuleSet(ctx.RULESET_REFERENCE().getText().trim())
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        if (this.currentDoc.ruleSets.has(ruleSet.name)) {
            FSHLogger_1.logger.error(`Skipping RuleSet: a RuleSet named ${ruleSet.name} already exists.`, {
                file: this.currentFile,
                location: this.extractStartStop(ctx)
            });
        }
        else {
            this.parseRuleSet(ruleSet, ctx.ruleSetRule());
            this.currentDoc.ruleSets.set(ruleSet.name, ruleSet);
        }
    }
    parseRuleSet(ruleSet, rules) {
        rules.forEach(rule => {
            if (rule.sdRule()) {
                ruleSet.rules.push(...this.visitSdRule(rule.sdRule()));
            }
            else if (rule.vsComponent()) {
                ruleSet.rules.push(this.visitVsComponent(rule.vsComponent()));
            }
            else if (rule.concept()) {
                ruleSet.rules.push(this.visitConcept(rule.concept()));
            }
        });
    }
    visitParamRuleSet(ctx) {
        const [rulesetName, ruleParams] = this.parseRulesetReference(ctx.PARAM_RULESET_REFERENCE().getText());
        const paramRuleSet = new fshtypes_1.ParamRuleSet(rulesetName)
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        if (this.paramRuleSets.has(paramRuleSet.name)) {
            FSHLogger_1.logger.error(`Skipping RuleSet: a RuleSet named ${paramRuleSet.name} already exists.`, {
                file: this.currentFile,
                location: this.extractStartStop(ctx)
            });
        }
        else {
            paramRuleSet.parameters = ruleParams
                .replace(/(^\()|(\)$)/g, '')
                .split(',')
                .map(param => param.trim());
            paramRuleSet.contents = this.visitParamRuleSetContent(ctx.paramRuleSetContent());
            const unusedParameters = paramRuleSet.getUnusedParameters();
            if (unusedParameters.length > 0) {
                FSHLogger_1.logger.warn(`RuleSet ${paramRuleSet.name} contains unused parameter${unusedParameters.length > 1 ? 's' : ''}: ${unusedParameters.join(', ')}`, paramRuleSet.sourceInfo);
            }
            this.paramRuleSets.set(paramRuleSet.name, paramRuleSet);
        }
    }
    visitParamRuleSetContent(ctx) {
        return ctx.start.getInputStream().getText(ctx.start.start, ctx.stop.stop);
    }
    visitMapping(ctx) {
        const mapping = new fshtypes_1.Mapping(ctx.SEQUENCE().getText())
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        if (this.currentDoc.mappings.has(mapping.name)) {
            FSHLogger_1.logger.error(`Skipping Mapping: a Mapping named ${mapping.name} already exists.`, {
                file: this.currentFile,
                location: this.extractStartStop(ctx)
            });
        }
        else {
            this.parseMapping(mapping, ctx.mappingMetadata(), ctx.mappingEntityRule());
            this.currentDoc.mappings.set(mapping.name, mapping);
        }
    }
    parseMapping(mapping, metaCtx = [], ruleCtx = []) {
        const seenPairs = new Map();
        metaCtx
            .map(mapMeta => (Object.assign(Object.assign({}, this.visitMappingMetadata(mapMeta)), { context: mapMeta })))
            .forEach(pair => {
            if (seenPairs.has(pair.key)) {
                FSHLogger_1.logger.error(`Metadata field '${pair.key}' already declared with value '${seenPairs.get(pair.key)}'.`, { file: this.currentFile, location: this.extractStartStop(pair.context) });
                return;
            }
            seenPairs.set(pair.key, pair.value);
            if (pair.key === MappingMetadataKey.Id) {
                mapping.id = pair.value;
            }
            else if (pair.key === MappingMetadataKey.Source) {
                mapping.source = pair.value;
            }
            else if (pair.key === MappingMetadataKey.Target) {
                mapping.target = pair.value;
            }
            else if (pair.key === MappingMetadataKey.Description) {
                mapping.description = pair.value;
            }
            else if (pair.key === MappingMetadataKey.Title) {
                mapping.title = pair.value;
            }
        });
        ruleCtx.forEach(mappingRule => {
            const rule = this.visitMappingEntityRule(mappingRule);
            if (rule) {
                mapping.rules.push(rule);
            }
        });
    }
    visitSdMetadata(ctx) {
        if (ctx.id()) {
            return { key: SdMetadataKey.Id, value: this.visitId(ctx.id()) };
        }
        else if (ctx.parent()) {
            return { key: SdMetadataKey.Parent, value: this.visitParent(ctx.parent()) };
        }
        else if (ctx.title()) {
            return { key: SdMetadataKey.Title, value: this.visitTitle(ctx.title()) };
        }
        else if (ctx.description()) {
            return { key: SdMetadataKey.Description, value: this.visitDescription(ctx.description()) };
        }
        else if (ctx.mixins()) {
            return { key: SdMetadataKey.Mixins, value: this.visitMixins(ctx.mixins()) };
        }
        return { key: SdMetadataKey.Unknown, value: ctx.getText() };
    }
    visitInstanceMetadata(ctx) {
        if (ctx.instanceOf()) {
            return { key: InstanceMetadataKey.InstanceOf, value: this.visitInstanceOf(ctx.instanceOf()) };
        }
        else if (ctx.title()) {
            return { key: InstanceMetadataKey.Title, value: this.visitTitle(ctx.title()) };
        }
        else if (ctx.description()) {
            return {
                key: InstanceMetadataKey.Description,
                value: this.visitDescription(ctx.description())
            };
        }
        else if (ctx.usage()) {
            return {
                key: InstanceMetadataKey.Usage,
                value: this.visitUsage(ctx.usage())
            };
        }
        else if (ctx.mixins()) {
            return { key: InstanceMetadataKey.Mixins, value: this.visitMixins(ctx.mixins()) };
        }
        return { key: InstanceMetadataKey.Unknown, value: ctx.getText() };
    }
    visitVsMetadata(ctx) {
        if (ctx.id()) {
            return { key: VsMetadataKey.Id, value: this.visitId(ctx.id()) };
        }
        else if (ctx.title()) {
            return { key: VsMetadataKey.Title, value: this.visitTitle(ctx.title()) };
        }
        else if (ctx.description()) {
            return { key: VsMetadataKey.Description, value: this.visitDescription(ctx.description()) };
        }
        return { key: VsMetadataKey.Unknown, value: ctx.getText() };
    }
    visitCsMetadata(ctx) {
        if (ctx.id()) {
            return { key: CsMetadataKey.Id, value: this.visitId(ctx.id()) };
        }
        else if (ctx.title()) {
            return { key: CsMetadataKey.Title, value: this.visitTitle(ctx.title()) };
        }
        else if (ctx.description()) {
            return { key: CsMetadataKey.Description, value: this.visitDescription(ctx.description()) };
        }
        return { key: CsMetadataKey.Unknown, value: ctx.getText() };
    }
    visitInvariantMetadata(ctx) {
        if (ctx.description()) {
            return {
                key: InvariantMetadataKey.Description,
                value: this.visitDescription(ctx.description())
            };
        }
        else if (ctx.expression()) {
            return {
                key: InvariantMetadataKey.Expression,
                value: this.visitExpression(ctx.expression())
            };
        }
        else if (ctx.xpath()) {
            return {
                key: InvariantMetadataKey.XPath,
                value: this.visitXpath(ctx.xpath())
            };
        }
        else if (ctx.severity()) {
            return {
                key: InvariantMetadataKey.Severity,
                value: this.visitSeverity(ctx.severity())
            };
        }
        return {
            key: InvariantMetadataKey.Unknown,
            value: ctx.getText()
        };
    }
    visitMappingMetadata(ctx) {
        if (ctx.id()) {
            return { key: MappingMetadataKey.Id, value: this.visitId(ctx.id()) };
        }
        else if (ctx.source()) {
            return { key: MappingMetadataKey.Source, value: this.visitSource(ctx.source()) };
        }
        else if (ctx.target()) {
            return { key: MappingMetadataKey.Target, value: this.visitTarget(ctx.target()) };
        }
        else if (ctx.description()) {
            return {
                key: MappingMetadataKey.Description,
                value: this.visitDescription(ctx.description())
            };
        }
        else if (ctx.title()) {
            return { key: MappingMetadataKey.Title, value: this.visitTitle(ctx.title()) };
        }
        return { key: MappingMetadataKey.Unknown, value: ctx.getText() };
    }
    visitId(ctx) {
        return ctx.SEQUENCE().getText();
    }
    visitParent(ctx) {
        return this.aliasAwareValue(ctx.SEQUENCE());
    }
    visitTitle(ctx) {
        return this.extractString(ctx.STRING());
    }
    visitDescription(ctx) {
        if (ctx.STRING()) {
            return this.extractString(ctx.STRING());
        }
        // it must be a multiline string
        return this.extractMultilineString(ctx.MULTILINE_STRING());
    }
    visitInstanceOf(ctx) {
        return this.aliasAwareValue(ctx.SEQUENCE());
    }
    visitMixins(ctx) {
        let mixins;
        if (ctx.COMMA_DELIMITED_SEQUENCES()) {
            mixins = ctx
                .COMMA_DELIMITED_SEQUENCES()
                .getText()
                .split(/\s*,\s*/);
        }
        else {
            mixins = ctx.SEQUENCE().map(sequence => sequence.getText());
        }
        mixins = mixins.filter((m, i) => {
            const duplicated = mixins.indexOf(m) !== i;
            if (duplicated) {
                FSHLogger_1.logger.warn(`Detected duplicated Mixin: ${m}. Ignoring duplicates.`, {
                    location: this.extractStartStop(ctx),
                    file: this.currentFile
                });
            }
            return !duplicated;
        });
        return mixins;
    }
    visitUsage(ctx) {
        var _a;
        const usageConcept = this.parseCodeLexeme(ctx.CODE().getText(), ctx.CODE())
            .withLocation(this.extractStartStop(ctx.CODE()))
            .withFile(this.currentFile);
        if (((_a = usageConcept.system) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            FSHLogger_1.logger.warn('Do not specify a system for instance Usage.', usageConcept.sourceInfo);
        }
        let usage = upperFirst_1.default(usageConcept.code);
        if (!fshtypes_1.isInstanceUsage(usage)) {
            FSHLogger_1.logger.error('Invalid Usage. Supported usage codes are "#example", "#definition", and "#inline". Instance will be treated as an example.', usageConcept.sourceInfo);
            usage = 'Example';
        }
        return usage;
    }
    visitExpression(ctx) {
        return this.extractString(ctx.STRING());
    }
    visitXpath(ctx) {
        return this.extractString(ctx.STRING());
    }
    visitSeverity(ctx) {
        var _a;
        const concept = this.parseCodeLexeme(ctx.CODE().getText(), ctx.CODE())
            .withLocation(this.extractStartStop(ctx.CODE()))
            .withFile(this.currentFile);
        if (((_a = concept.system) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            FSHLogger_1.logger.warn('Do not specify a system for invariant severity.', concept.sourceInfo);
        }
        if (concept.code != 'error' && concept.code != 'warning') {
            FSHLogger_1.logger.error('Invalid invariant severity code: code must be "#error" or "#warning".', concept.sourceInfo);
        }
        return concept;
    }
    visitSource(ctx) {
        return this.aliasAwareValue(ctx.SEQUENCE());
    }
    visitTarget(ctx) {
        return this.extractString(ctx.STRING());
    }
    parseCodeLexeme(conceptText, parentCtx) {
        var _a;
        const concept = parseCodeLexeme_1.parseCodeLexeme(conceptText);
        if (((_a = concept.system) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            concept.system = this.aliasAwareValue(parentCtx, concept.system);
        }
        return concept;
    }
    visitSdRule(ctx) {
        if (ctx.cardRule()) {
            return this.visitCardRule(ctx.cardRule());
        }
        else if (ctx.flagRule()) {
            return this.visitFlagRule(ctx.flagRule());
        }
        else if (ctx.valueSetRule()) {
            return [this.visitValueSetRule(ctx.valueSetRule())];
        }
        else if (ctx.fixedValueRule()) {
            const rule = this.visitFixedValueRule(ctx.fixedValueRule());
            return [rule];
        }
        else if (ctx.onlyRule()) {
            return [this.visitOnlyRule(ctx.onlyRule())];
        }
        else if (ctx.containsRule()) {
            return this.visitContainsRule(ctx.containsRule());
        }
        else if (ctx.caretValueRule()) {
            return [this.visitCaretValueRule(ctx.caretValueRule())];
        }
        else if (ctx.obeysRule()) {
            return this.visitObeysRule(ctx.obeysRule());
        }
        else if (ctx.insertRule()) {
            const rule = this.visitInsertRule(ctx.insertRule());
            return rule ? [rule] : [];
        }
        FSHLogger_1.logger.warn(`Unsupported rule: ${ctx.getText()}`, {
            file: this.currentFile,
            location: this.extractStartStop(ctx)
        });
        return [];
    }
    visitInstanceRule(ctx) {
        if (ctx.fixedValueRule()) {
            return this.visitFixedValueRule(ctx.fixedValueRule());
        }
        else if (ctx.insertRule()) {
            return this.visitInsertRule(ctx.insertRule());
        }
    }
    visitVsRule(ctx) {
        if (ctx.vsComponent()) {
            return this.visitVsComponent(ctx.vsComponent());
        }
        if (ctx.caretValueRule()) {
            const rule = this.visitCaretValueRule(ctx.caretValueRule());
            if (rule.path) {
                FSHLogger_1.logger.error('Caret rule on ValueSet cannot contain path before ^, skipping rule.', rule.sourceInfo);
            }
            else {
                return this.visitCaretValueRule(ctx.caretValueRule());
            }
        }
        else if (ctx.insertRule()) {
            return this.visitInsertRule(ctx.insertRule());
        }
    }
    visitCsRule(ctx) {
        if (ctx.concept()) {
            return this.visitConcept(ctx.concept());
        }
        else if (ctx.caretValueRule()) {
            const rule = this.visitCaretValueRule(ctx.caretValueRule());
            if (rule.path) {
                FSHLogger_1.logger.error('Caret rule on CodeSystem cannot contain path before ^, skipping rule.', rule.sourceInfo);
            }
            else {
                return this.visitCaretValueRule(ctx.caretValueRule());
            }
        }
        else if (ctx.insertRule()) {
            return this.visitInsertRule(ctx.insertRule());
        }
    }
    visitMappingEntityRule(ctx) {
        if (ctx.mappingRule()) {
            return this.visitMappingRule(ctx.mappingRule());
        }
        else if (ctx.insertRule()) {
            return this.visitInsertRule(ctx.insertRule());
        }
    }
    visitPath(ctx) {
        if (ctx.KW_SYSTEM()) {
            return ctx.KW_SYSTEM().getText();
        }
        return ctx.SEQUENCE().getText();
    }
    visitCaretPath(ctx) {
        return ctx.CARET_SEQUENCE().getText();
    }
    visitPaths(ctx) {
        return ctx
            .COMMA_DELIMITED_SEQUENCES()
            .getText()
            .split(/\s*,\s*/);
    }
    visitCardRule(ctx) {
        const rules = [];
        const cardRule = new rules_1.CardRule(this.visitPath(ctx.path()))
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        const card = this.parseCard(ctx.CARD().getText(), cardRule);
        cardRule.min = card.min;
        cardRule.max = card.max;
        rules.push(cardRule);
        if (ctx.flag() && ctx.flag().length > 0) {
            const flagRule = new rules_1.FlagRule(cardRule.path)
                .withLocation(this.extractStartStop(ctx))
                .withFile(this.currentFile);
            this.parseFlags(flagRule, ctx.flag());
            rules.push(flagRule);
        }
        return rules;
    }
    parseCard(card, rule) {
        const parts = card.split('..', 2);
        if (parts[0] === '' && parts[1] === '') {
            FSHLogger_1.logger.error(`Neither side of the cardinality was specified on path "${rule.path}". A min, max, or both need to be specified.`, rule.sourceInfo);
        }
        return {
            min: parseInt(parts[0]),
            max: parts[1]
        };
    }
    visitFlagRule(ctx) {
        let paths;
        if (ctx.path().length > 0) {
            paths = ctx.path().map(path => this.visitPath(path));
        }
        else if (ctx.paths()) {
            FSHLogger_1.logger.warn('Using "," to list paths is deprecated. Please use "and" to list paths.', {
                file: this.currentFile,
                location: this.extractStartStop(ctx.paths())
            });
            paths = this.visitPaths(ctx.paths());
        }
        return paths.map(path => {
            const flagRule = new rules_1.FlagRule(path)
                .withLocation(this.extractStartStop(ctx))
                .withFile(this.currentFile);
            this.parseFlags(flagRule, ctx.flag());
            return flagRule;
        });
    }
    parseFlags(flagRule, flagContext) {
        const flags = flagContext.map(f => this.visitFlag(f));
        if (flags.includes(Flag.MustSupport)) {
            flagRule.mustSupport = true;
        }
        if (flags.includes(Flag.Summary)) {
            flagRule.summary = true;
        }
        if (flags.includes(Flag.Modifier)) {
            flagRule.modifier = true;
        }
        if (flags.includes(Flag.TrialUse)) {
            flagRule.trialUse = true;
        }
        if (flags.includes(Flag.Normative)) {
            flagRule.normative = true;
        }
        if (flags.includes(Flag.Draft)) {
            flagRule.draft = true;
        }
    }
    visitFlag(ctx) {
        if (ctx.KW_MS()) {
            return Flag.MustSupport;
        }
        else if (ctx.KW_SU()) {
            return Flag.Summary;
        }
        else if (ctx.KW_MOD()) {
            return Flag.Modifier;
        }
        else if (ctx.KW_TU()) {
            return Flag.TrialUse;
        }
        else if (ctx.KW_NORMATIVE()) {
            return Flag.Normative;
        }
        else if (ctx.KW_DRAFT()) {
            return Flag.Draft;
        }
        return Flag.Unknown;
    }
    visitValueSetRule(ctx) {
        const vsRule = new rules_1.BindingRule(this.visitPath(ctx.path()))
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        vsRule.valueSet = this.aliasAwareValue(ctx.SEQUENCE());
        vsRule.strength = ctx.strength() ? this.visitStrength(ctx.strength()) : 'required';
        if (ctx.KW_UNITS()) {
            FSHLogger_1.logger.warn('The "units" keyword is deprecated and has no effect. Support will be removed entirely in a future release.', vsRule.sourceInfo);
        }
        return vsRule;
    }
    visitStrength(ctx) {
        if (ctx.KW_EXAMPLE()) {
            return 'example';
        }
        else if (ctx.KW_PREFERRED()) {
            return 'preferred';
        }
        else if (ctx.KW_EXTENSIBLE()) {
            return 'extensible';
        }
        return 'required';
    }
    visitFixedValueRule(ctx) {
        const assignmentRule = new rules_1.AssignmentRule(this.visitPath(ctx.path()))
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        assignmentRule.value = this.visitValue(ctx.value());
        assignmentRule.exactly = ctx.KW_EXACTLY() != null;
        if (ctx.KW_UNITS()) {
            FSHLogger_1.logger.warn('The "units" keyword is deprecated and has no effect. Support will be removed entirely in a future release.', assignmentRule.sourceInfo);
        }
        assignmentRule.isInstance =
            ctx.value().SEQUENCE() != null && !this.allAliases.has(ctx.value().SEQUENCE().getText());
        return assignmentRule;
    }
    visitValue(ctx) {
        // In cases where the parser encounters an error, ctx might be null
        if (ctx == null) {
            return;
        }
        if (ctx.SEQUENCE()) {
            return this.aliasAwareValue(ctx, ctx.SEQUENCE().getText());
        }
        if (ctx.STRING()) {
            return this.extractString(ctx.STRING());
        }
        if (ctx.MULTILINE_STRING()) {
            return this.extractMultilineString(ctx.MULTILINE_STRING());
        }
        if (ctx.NUMBER()) {
            return parseFloat(ctx.NUMBER().getText());
        }
        if (ctx.DATETIME()) {
            // for now, treat datetime like a string
            return ctx.DATETIME().getText();
        }
        if (ctx.TIME()) {
            // for now, treat datetime like a string
            return ctx.TIME().getText();
        }
        if (ctx.reference()) {
            return this.visitReference(ctx.reference());
        }
        if (ctx.canonical()) {
            return this.visitCanonical(ctx.canonical());
        }
        if (ctx.code()) {
            return this.visitCode(ctx.code());
        }
        if (ctx.quantity()) {
            return this.visitQuantity(ctx.quantity());
        }
        if (ctx.ratio()) {
            return this.visitRatio(ctx.ratio());
        }
        if (ctx.bool()) {
            return this.visitBool(ctx.bool());
        }
    }
    visitCode(ctx) {
        const concept = this.parseCodeLexeme(ctx.CODE().getText(), ctx.CODE())
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        if (ctx.STRING()) {
            concept.display = this.extractString(ctx.STRING());
        }
        return concept;
    }
    visitConcept(ctx) {
        const codePart = this.visitCode(ctx.code());
        const concept = new rules_1.ConceptRule(codePart.code, codePart.display)
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        if (codePart.system) {
            FSHLogger_1.logger.error('Do not include the system when listing concepts for a code system.', concept.sourceInfo);
            // If this is on a ruleset, and if this rule is then used on a ValueSet, this could actually
            // be a ValueSetConceptComponent, and not a ConceptRule, in which case we should carry through
            // the system
            concept.system = codePart.system;
        }
        if (ctx.STRING()) {
            concept.definition = this.extractString(ctx.STRING());
        }
        else if (ctx.MULTILINE_STRING()) {
            concept.definition = this.extractMultilineString(ctx.MULTILINE_STRING());
        }
        return concept;
    }
    visitQuantity(ctx) {
        const value = parseFloat(ctx.NUMBER().getText());
        const delimitedUnit = ctx.UNIT().getText(); // e.g., 'mm'
        let displayUnit;
        if (ctx.STRING()) {
            displayUnit = this.extractString(ctx.STRING());
        }
        // the literal version of quantity always assumes UCUM code system
        const unit = new fshtypes_1.FshCode(delimitedUnit.slice(1, -1), 'http://unitsofmeasure.org', displayUnit)
            .withLocation(this.extractStartStop(ctx.UNIT()))
            .withFile(this.currentFile);
        const quantity = new fshtypes_1.FshQuantity(value, unit)
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        return quantity;
    }
    visitRatio(ctx) {
        const ratio = new fshtypes_1.FshRatio(this.visitRatioPart(ctx.ratioPart()[0]), this.visitRatioPart(ctx.ratioPart()[1]))
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        return ratio;
    }
    visitRatioPart(ctx) {
        if (ctx.NUMBER()) {
            const quantity = new fshtypes_1.FshQuantity(parseFloat(ctx.NUMBER().getText()))
                .withLocation(this.extractStartStop(ctx.NUMBER()))
                .withFile(this.currentFile);
            return quantity;
        }
        return this.visitQuantity(ctx.quantity());
    }
    // This function is called when fixing a value, and a value can only be set
    // to a specific reference, not a choice of references.
    visitReference(ctx) {
        let ref;
        let parsedReferences;
        if (ctx.OR_REFERENCE()) {
            parsedReferences = this.parseOrReference(ctx.OR_REFERENCE().getText());
            ref = new fshtypes_1.FshReference(this.aliasAwareValue(ctx.OR_REFERENCE(), parsedReferences[0]));
        }
        else {
            parsedReferences = this.parsePipeReference(ctx.PIPE_REFERENCE().getText());
            ref = new fshtypes_1.FshReference(this.aliasAwareValue(ctx.PIPE_REFERENCE(), parsedReferences[0]));
            FSHLogger_1.logger.warn('Using "|" to list references is deprecated. Please use "or" to list references.', {
                file: this.currentFile,
                location: this.extractStartStop(ctx)
            });
        }
        if (parsedReferences.length > 1) {
            FSHLogger_1.logger.error('Multiple choices of references are not allowed when setting a value. Only the first choice will be used.', {
                file: this.currentFile,
                location: this.extractStartStop(ctx)
            });
        }
        ref.withLocation(this.extractStartStop(ctx)).withFile(this.currentFile);
        if (ctx.STRING()) {
            ref.display = this.extractString(ctx.STRING());
        }
        return ref;
    }
    parseOrReference(reference) {
        return reference
            .slice(reference.indexOf('(') + 1, reference.length - 1)
            .split(/\s+or\s+/)
            .map(r => r.trim());
    }
    parsePipeReference(reference) {
        return reference
            .slice(reference.indexOf('(') + 1, reference.length - 1)
            .split(/\s*\|\s*/)
            .map(r => r.trim());
    }
    visitCanonical(ctx) {
        const [canonicalText, versionText] = this.parseCanonical(ctx.CANONICAL().getText());
        const fshCanonical = new fshtypes_1.FshCanonical(canonicalText)
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        if (versionText) {
            fshCanonical.version = versionText;
        }
        return fshCanonical;
    }
    parseCanonical(canonical) {
        return canonical
            .slice(canonical.indexOf('(') + 1, canonical.length - 1)
            .split(/\s*\|\s*(.+)/)
            .map(str => str.trim());
    }
    visitBool(ctx) {
        return ctx.KW_TRUE() != null;
    }
    visitOnlyRule(ctx) {
        const onlyRule = new rules_1.OnlyRule(this.visitPath(ctx.path()))
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        ctx.targetType().forEach(t => {
            if (t.reference()) {
                let referenceToken;
                let references;
                if (t.reference().OR_REFERENCE()) {
                    referenceToken = t.reference().OR_REFERENCE();
                    references = this.parseOrReference(referenceToken.getText());
                }
                else {
                    referenceToken = t.reference().PIPE_REFERENCE();
                    references = this.parsePipeReference(referenceToken.getText());
                    FSHLogger_1.logger.warn('Using "|" to list references is deprecated. Please use "or" to list references.', {
                        file: this.currentFile,
                        location: this.extractStartStop(ctx)
                    });
                }
                references.forEach(r => onlyRule.types.push({
                    type: this.aliasAwareValue(referenceToken, r),
                    isReference: true
                }));
            }
            else {
                onlyRule.types.push({ type: this.aliasAwareValue(t.SEQUENCE()) });
            }
        });
        return onlyRule;
    }
    visitContainsRule(ctx) {
        const rules = [];
        const containsRule = new rules_1.ContainsRule(this.visitPath(ctx.path()))
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        rules.push(containsRule);
        ctx.item().forEach(i => {
            let item;
            if (i.KW_NAMED()) {
                item = {
                    type: this.aliasAwareValue(i.SEQUENCE()[0], i.SEQUENCE()[0].getText()),
                    name: i.SEQUENCE()[1].getText()
                };
            }
            else {
                item = {
                    name: i.SEQUENCE()[0].getText()
                };
            }
            containsRule.items.push(item);
            const cardRule = new rules_1.CardRule(`${containsRule.path}[${item.name}]`)
                .withLocation(this.extractStartStop(i))
                .withFile(this.currentFile);
            const card = this.parseCard(i.CARD().getText(), cardRule);
            cardRule.min = card.min;
            cardRule.max = card.max;
            rules.push(cardRule);
            if (i.flag() && i.flag().length > 0) {
                const flagRule = new rules_1.FlagRule(`${containsRule.path}[${item.name}]`)
                    .withLocation(this.extractStartStop(i))
                    .withFile(this.currentFile);
                this.parseFlags(flagRule, i.flag());
                rules.push(flagRule);
            }
        });
        return rules;
    }
    visitCaretValueRule(ctx) {
        var _a;
        const path = ctx.path() ? this.visitPath(ctx.path()) : '';
        const caretValueRule = new rules_1.CaretValueRule(path)
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        // Get the caret path, but slice off the starting ^
        caretValueRule.caretPath = this.visitCaretPath(ctx.caretPath()).slice(1);
        caretValueRule.value = this.visitValue(ctx.value());
        caretValueRule.isInstance =
            ((_a = ctx.value()) === null || _a === void 0 ? void 0 : _a.SEQUENCE()) != null && !this.allAliases.has(ctx.value().SEQUENCE().getText());
        return caretValueRule;
    }
    visitObeysRule(ctx) {
        const rules = [];
        const path = ctx.path() ? this.visitPath(ctx.path()) : '';
        ctx.SEQUENCE().forEach(invariant => {
            const obeysRule = new rules_1.ObeysRule(path)
                .withLocation(this.extractStartStop(ctx))
                .withFile(this.currentFile);
            obeysRule.invariant = invariant.getText();
            rules.push(obeysRule);
        });
        return rules;
    }
    visitInsertRule(ctx) {
        var _a, _b;
        const insertRule = new rules_1.InsertRule()
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        const [rulesetName, ruleParams] = this.parseRulesetReference((_b = (_a = ctx.RULESET_REFERENCE()) === null || _a === void 0 ? void 0 : _a.getText()) !== null && _b !== void 0 ? _b : ctx.PARAM_RULESET_REFERENCE().getText());
        insertRule.ruleSet = rulesetName;
        if (ruleParams) {
            insertRule.params = this.parseInsertRuleParams(ruleParams);
            const ruleSet = this.paramRuleSets.get(insertRule.ruleSet);
            if (ruleSet) {
                const ruleSetIdentifier = JSON.stringify([ruleSet.name, ...insertRule.params]);
                if (ruleSet.parameters.length === insertRule.params.length) {
                    // no need to create the appliedRuleSet again if we already have it
                    if (!this.currentDoc.appliedRuleSets.has(ruleSetIdentifier)) {
                        // create a new document with the substituted parameters
                        const appliedFsh = `RuleSet: ${ruleSet.name}${os_1.EOL}${ruleSet.applyParameters(insertRule.params)}${os_1.EOL}`;
                        const appliedRuleSet = this.parseGeneratedRuleSet(appliedFsh, ruleSet.name, ctx, insertRule);
                        if (appliedRuleSet) {
                            // set the source info based on the original source info
                            appliedRuleSet.sourceInfo.file = ruleSet.sourceInfo.file;
                            appliedRuleSet.sourceInfo.location = Object.assign({}, ruleSet.sourceInfo.location);
                            appliedRuleSet.rules.forEach(rule => {
                                rule.sourceInfo.file = appliedRuleSet.sourceInfo.file;
                                rule.sourceInfo.location.startLine +=
                                    appliedRuleSet.sourceInfo.location.startLine - 1;
                                rule.sourceInfo.location.endLine +=
                                    appliedRuleSet.sourceInfo.location.startLine - 1;
                            });
                            this.currentDoc.appliedRuleSets.set(ruleSetIdentifier, appliedRuleSet);
                        }
                        else {
                            FSHLogger_1.logger.error(`Failed to parse RuleSet ${insertRule.ruleSet} with provided parameters (${insertRule.params.join(', ')})`, insertRule.sourceInfo);
                            return;
                        }
                    }
                }
                else {
                    FSHLogger_1.logger.error(`Incorrect number of parameters applied to RuleSet ${insertRule.ruleSet}`, insertRule.sourceInfo);
                    return;
                }
            }
            else {
                FSHLogger_1.logger.error(`Could not find parameterized RuleSet named ${insertRule.ruleSet}`, insertRule.sourceInfo);
                return;
            }
        }
        return insertRule;
    }
    parseRulesetReference(reference) {
        const paramListStart = reference.indexOf('(');
        if (paramListStart === -1) {
            return [reference.trim(), null];
        }
        else {
            return [reference.slice(0, paramListStart).trim(), reference.slice(paramListStart)];
        }
    }
    parseInsertRuleParams(ruleText) {
        // first, trim parentheses
        const ruleNoParens = ruleText.slice(1, ruleText.length - 1);
        // since backslash is the escape character, deal with literal backslash first
        const splitBackslash = ruleNoParens.split(/\\\\/g);
        // then, split the parameters apart with unescaped commas
        const splitComma = splitBackslash.map(substrBackslash => {
            return substrBackslash.split(/(?<!\\),/g).map(substrComma => {
                // then, make all the replacements: closing parenthesis and comma
                return substrComma.replace(/\\\)/g, ')').replace(/\\,/g, ',');
            });
        });
        const paramList = [];
        // if splitComma has more than one list, that means we split on literal backslash
        // so to rejoin all the strings, the last string joins the first string in the next sublist
        splitComma.forEach((list, index) => {
            list.forEach((paramPart, subIndex) => {
                if (index > 0 && subIndex === 0) {
                    // join with \\ on the last param
                    paramList.push(`${paramList.pop()}\\\\${paramPart}`);
                }
                else {
                    // push a new param
                    paramList.push(paramPart);
                }
            });
        });
        // trim whitespace from each parameter, since it may be formatted for readability
        return paramList.map(param => param.trim());
    }
    parseGeneratedRuleSet(input, name, ctx, insertRule) {
        // define a temporary document that will contain this RuleSet
        const tempDocument = new FSHDocument_1.FSHDocument(this.currentFile);
        // save the currentDoc so it can be restored after parsing this RuleSet
        const parentDocument = this.currentDoc;
        this.currentDoc = tempDocument;
        // errors should be collected, not printed, when parsing generated documents
        // we should only retrieve errors if we are currently in the top-level parse
        let topLevelInfo;
        if (this.topLevelParse) {
            this.topLevelParse = false;
            topLevelInfo = FSHLogger_1.switchToSecretLogger();
        }
        try {
            const subContext = this.parseDoc(input);
            this.visitDoc(subContext);
        }
        finally {
            // be sure to restore parentDocument
            this.currentDoc = parentDocument;
        }
        // if tempDocument has appliedRuleSets, merge them in
        tempDocument.appliedRuleSets.forEach((ruleSet, identifier) => this.currentDoc.appliedRuleSets.set(identifier, ruleSet));
        if (topLevelInfo) {
            // exit logger collection mode, write collected errors and warnings
            const collectedMessages = FSHLogger_1.restoreMainLogger(topLevelInfo);
            this.topLevelParse = true;
            if (collectedMessages.errors.length > 0) {
                FSHLogger_1.logger.error([
                    `Error${collectedMessages.errors.length > 1 ? 's' : ''} parsing insert rule with parameterized RuleSet ${name}`,
                    ...collectedMessages.errors.map(log => `- ${log.message}`)
                ].join(os_1.EOL), insertRule.sourceInfo);
            }
            if (collectedMessages.warnings.length > 0) {
                FSHLogger_1.logger.warn([
                    `Warning${collectedMessages.warnings.length > 1 ? 's' : ''} parsing insert rule with parameterized RuleSet ${name}`,
                    ...collectedMessages.warnings.map(log => `- ${log.message}`)
                ].join(os_1.EOL), insertRule.sourceInfo);
            }
        }
        // if the RuleSet parsed successfully, it will be on the document, and we should return it.
        return tempDocument.ruleSets.get(name);
    }
    visitMappingRule(ctx) {
        var _a;
        const path = ctx.path() ? this.visitPath(ctx.path()) : '';
        const mappingRule = new rules_1.MappingRule(path)
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        mappingRule.map = this.extractString(ctx.STRING()[0]);
        if (ctx.STRING().length > 1) {
            mappingRule.comment = this.extractString(ctx.STRING()[1]);
        }
        if (ctx.CODE()) {
            mappingRule.language = this.parseCodeLexeme(ctx.CODE().getText(), ctx.CODE())
                .withLocation(this.extractStartStop(ctx.CODE()))
                .withFile(this.currentFile);
            if (((_a = mappingRule.language.system) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                FSHLogger_1.logger.warn('Do not specify a system for mapping language.', mappingRule.language.sourceInfo);
            }
        }
        return mappingRule;
    }
    visitVsComponent(ctx) {
        const inclusion = ctx.KW_EXCLUDE() == null;
        let vsComponent;
        if (ctx.vsConceptComponent()) {
            vsComponent = new rules_1.ValueSetConceptComponentRule(inclusion);
            [vsComponent.concepts, vsComponent.from] = this.visitVsConceptComponent(ctx.vsConceptComponent());
        }
        else if (ctx.vsFilterComponent()) {
            vsComponent = new rules_1.ValueSetFilterComponentRule(inclusion);
            [vsComponent.filters, vsComponent.from] = this.visitVsFilterComponent(ctx.vsFilterComponent());
        }
        return vsComponent;
    }
    visitVsConceptComponent(ctx) {
        const concepts = [];
        const from = ctx.vsComponentFrom()
            ? this.visitVsComponentFrom(ctx.vsComponentFrom())
            : {};
        if (ctx.code().length === 1) {
            const singleCode = this.visitCode(ctx.code()[0]);
            if (singleCode.system && from.system) {
                FSHLogger_1.logger.error(`Concept ${singleCode.code} specifies system multiple times`, {
                    file: this.currentFile,
                    location: this.extractStartStop(ctx)
                });
            }
            else if (singleCode.system) {
                from.system = singleCode.system;
                concepts.push(singleCode);
            }
            else if (from.system) {
                singleCode.system = from.system;
                concepts.push(singleCode);
            }
            else {
                FSHLogger_1.logger.error(`Concept ${singleCode.code} must include system as "SYSTEM#CONCEPT" or "#CONCEPT from system SYSTEM"`, {
                    file: this.currentFile,
                    location: this.extractStartStop(ctx)
                });
            }
        }
        else if (ctx.code().length > 1) {
            if (from.system) {
                ctx.code().forEach(code => {
                    const newCode = this.visitCode(code);
                    newCode.system = from.system;
                    concepts.push(newCode);
                });
            }
            else {
                FSHLogger_1.logger.error('System is required when listing concepts in a value set component', {
                    file: this.currentFile,
                    location: this.extractStartStop(ctx)
                });
            }
        }
        else if (ctx.COMMA_DELIMITED_CODES()) {
            FSHLogger_1.logger.warn('Using "," to list concepts is deprecated. Please use "and" to list concepts.', {
                file: this.currentFile,
                location: this.extractStartStop(ctx)
            });
            if (from.system) {
                const codes = ctx
                    .COMMA_DELIMITED_CODES()
                    .getText()
                    .split(/\s*,\s+#/);
                codes[0] = codes[0].slice(1);
                const location = this.extractStartStop(ctx.COMMA_DELIMITED_CODES());
                codes.forEach(code => {
                    var _a;
                    let codePart, description;
                    if (code.charAt(0) == '"') {
                        // codePart is a quoted string, just like description (if present).
                        [codePart, description] = code
                            .match(/"([^\s\\"]|\\"|\\\\)+(\s([^\s\\"]|\\"|\\\\)+)*"/g)
                            .map(quotedString => quotedString.slice(1, -1));
                    }
                    else {
                        // codePart is not a quoted string.
                        // if there is a description after the code,
                        // it will be separated by whitespace before the leading "
                        const codeEnd = (_a = code.match(/\s+"/)) === null || _a === void 0 ? void 0 : _a.index;
                        if (codeEnd) {
                            codePart = code.slice(0, codeEnd);
                            description = code.slice(codeEnd).trim().slice(1, -1);
                        }
                        else {
                            codePart = code.trim();
                        }
                    }
                    concepts.push(new fshtypes_1.FshCode(codePart, from.system, description)
                        .withLocation(location)
                        .withFile(this.currentFile));
                });
            }
            else {
                FSHLogger_1.logger.error('System is required when listing concepts in a value set component', {
                    file: this.currentFile,
                    location: this.extractStartStop(ctx)
                });
            }
        }
        return [concepts, from];
    }
    visitVsFilterComponent(ctx) {
        const filters = [];
        const from = ctx.vsComponentFrom()
            ? this.visitVsComponentFrom(ctx.vsComponentFrom())
            : {};
        if (ctx.vsFilterList()) {
            if (from.system) {
                ctx
                    .vsFilterList()
                    .vsFilterDefinition()
                    .forEach(filterDefinition => {
                    try {
                        filters.push(this.visitVsFilterDefinition(filterDefinition));
                    }
                    catch (e) {
                        FSHLogger_1.logger.error(e, {
                            location: this.extractStartStop(filterDefinition),
                            file: this.currentFile
                        });
                    }
                });
            }
            else {
                FSHLogger_1.logger.error('System is required when filtering a value set component', {
                    file: this.currentFile,
                    location: this.extractStartStop(ctx)
                });
            }
        }
        return [filters, from];
    }
    visitVsComponentFrom(ctx) {
        const from = {};
        if (ctx.vsFromSystem()) {
            from.system = this.aliasAwareValue(ctx.vsFromSystem().SEQUENCE());
        }
        if (ctx.vsFromValueset()) {
            if (ctx.vsFromValueset().SEQUENCE().length > 0) {
                from.valueSets = ctx
                    .vsFromValueset()
                    .SEQUENCE()
                    .map(sequence => this.aliasAwareValue(sequence));
            }
            else if (ctx.vsFromValueset().COMMA_DELIMITED_SEQUENCES()) {
                FSHLogger_1.logger.warn('Using "," to list valuesets is deprecated. Please use "and" to list valuesets.', {
                    file: this.currentFile,
                    location: this.extractStartStop(ctx)
                });
                from.valueSets = ctx
                    .vsFromValueset()
                    .COMMA_DELIMITED_SEQUENCES()
                    .getText()
                    .split(/\s*,\s*/)
                    .map(fromVs => this.aliasAwareValue(ctx.vsFromValueset().COMMA_DELIMITED_SEQUENCES(), fromVs.trim()));
            }
        }
        return from;
    }
    /**
     * The replace makes FSH permissive in regards to the official specifications,
     * which spells operator "descendant-of" as "descendent-of".
     * @see {@link http://hl7.org/fhir/valueset-filter-operator.html}
     */
    visitVsFilterDefinition(ctx) {
        const property = ctx.SEQUENCE().getText();
        const operator = ctx
            .vsFilterOperator()
            .getText()
            .toLocaleLowerCase()
            .replace('descendant', 'descendent');
        if (ctx.vsFilterValue() == null && operator !== fshtypes_1.VsOperator.EXISTS) {
            throw new errors_1.ValueSetFilterMissingValueError(operator);
        }
        const value = ctx.vsFilterValue() ? this.visitVsFilterValue(ctx.vsFilterValue()) : true;
        switch (operator) {
            case fshtypes_1.VsOperator.EQUALS:
            case fshtypes_1.VsOperator.IN:
            case fshtypes_1.VsOperator.NOT_IN:
                if (typeof value !== 'string') {
                    throw new errors_1.ValueSetFilterValueTypeError(operator, 'string');
                }
                break;
            case fshtypes_1.VsOperator.IS_A:
            case fshtypes_1.VsOperator.DESCENDENT_OF:
            case fshtypes_1.VsOperator.IS_NOT_A:
            case fshtypes_1.VsOperator.GENERALIZES:
                if (!(value instanceof fshtypes_1.FshCode)) {
                    throw new errors_1.ValueSetFilterValueTypeError(operator, 'code');
                }
                break;
            case fshtypes_1.VsOperator.REGEX:
                if (!(value instanceof RegExp)) {
                    throw new errors_1.ValueSetFilterValueTypeError(operator, 'regex');
                }
                break;
            case fshtypes_1.VsOperator.EXISTS:
                if (typeof value !== 'boolean') {
                    throw new errors_1.ValueSetFilterValueTypeError(operator, 'boolean');
                }
                break;
            default:
                throw new errors_1.ValueSetFilterOperatorError(ctx.vsFilterOperator().getText());
        }
        return {
            property: property,
            operator: operator,
            value: value
        };
    }
    visitVsFilterValue(ctx) {
        if (ctx.code()) {
            return this.visitCode(ctx.code());
        }
        else if (ctx.REGEX()) {
            return RegExp(ctx.REGEX().getText().slice(1, -1));
        }
        else if (ctx.STRING()) {
            return this.extractString(ctx.STRING());
        }
        else if (ctx.KW_TRUE()) {
            return true;
        }
        else if (ctx.KW_FALSE()) {
            return false;
        }
    }
    validateAliasResolves(parentCtx, value = parentCtx.getText()) {
        const hasAlias = this.allAliases.has(value);
        if (!hasAlias && value.startsWith('$')) {
            FSHLogger_1.logger.error(`Value ${value} does not resolve as alias, values beginning with "$" must resolve`, { location: this.extractStartStop(parentCtx), file: this.currentFile });
        }
    }
    aliasAwareValue(parentCtx, value = parentCtx.getText()) {
        const [valueWithoutVersion, version] = value.split('|');
        this.validateAliasResolves(parentCtx, valueWithoutVersion);
        if (this.allAliases.has(valueWithoutVersion)) {
            return this.allAliases.get(valueWithoutVersion) + (version ? `|${version}` : '');
        }
        else {
            return value;
        }
    }
    extractString(stringCtx) {
        var _a;
        const str = (_a = stringCtx === null || stringCtx === void 0 ? void 0 : stringCtx.getText()) !== null && _a !== void 0 ? _a : '""'; // default to empty string if stringCtx is null
        const strNoQuotes = str.slice(1, str.length - 1); // Strip surrounding quotes
        // Replace escaped characters
        const splitBackslash = strNoQuotes.split(/\\\\/g);
        const replacedBackslash = splitBackslash.map(substrBackslash => {
            // Replace quote, newline, return, tab characters only if they were not preceded by a backslash to escape the escape character
            return substrBackslash
                .replace(/\\"/g, '"')
                .replace(/\\n/g, '\n')
                .replace(/\\r/g, '\r')
                .replace(/\\t/g, '\t');
        });
        return replacedBackslash.join('\\');
    }
    /**
     * Multiline strings receive special handling:
     * - if the first line contains only whitespace (including newline), toss it
     * - if the last line contains only whitespace (including newline), toss it
     * - if another line contains only whitespace, truncate it
     * - for all other non-whitespace lines, detect the shortest number of leading spaces and always trim that off;
     *   this allows authors to indent a whole block of text, but not have it indented in the output.
     */
    extractMultilineString(mlStringCtx) {
        let mlstr = mlStringCtx.getText();
        // remove leading/trailing """
        mlstr = mlstr.slice(3, -3);
        // split into lines so we can process them to determine what leading spaces to trim
        let lines = mlstr.split(/\r?\n/);
        lines = lines.map(l => (l = l.replace(/\\n/g, '\n').replace(/\\r/g, '\r').replace(/\\t/g, '\t')));
        // if the first line is only whitespace, remove it
        if (lines[0].search(/\S/) === -1) {
            lines.shift();
        }
        // if the last line is only whitespace, remove it
        if (lines.length > 0 && lines[lines.length - 1].search(/\S/) === -1) {
            lines.pop();
        }
        lines = lines.map(l => (/^\s*$/.test(l) ? '' : l));
        // find the minimum number of spaces before the first char (ignore zero-length lines)
        const minSpaces = min_1.default(lines.map(line => {
            const firstNonSpace = line.search(/\S|$/);
            const lineIsEmpty = /^$/.test(line);
            if (!lineIsEmpty) {
                return firstNonSpace;
            }
            else {
                return null;
            }
        }));
        // consistently remove the common leading spaces and join the lines back together
        return lines.map(l => (l.length >= minSpaces ? l.slice(minSpaces) : l)).join('\n');
    }
    extractStartStop(ctx) {
        if (ctx instanceof Tree_1.TerminalNode) {
            return {
                startLine: ctx.symbol.line,
                startColumn: ctx.symbol.column + 1,
                endLine: ctx.symbol.line,
                endColumn: ctx.symbol.stop - ctx.symbol.start + ctx.symbol.column + 1
            };
        }
        else {
            return {
                startLine: ctx.start.line,
                startColumn: ctx.start.column + 1,
                endLine: ctx.stop.line,
                endColumn: ctx.stop.stop - ctx.stop.start + ctx.stop.column + 1
            };
        }
    }
    // NOTE: Since the ANTLR parser/lexer is JS (not typescript), we need to use some ts-ignore here.
    parseDoc(input, file) {
        const chars = new antlr4_1.InputStream(input);
        const lexer = new FSHLexer_1.FSHLexer(chars);
        const listener = new FSHErrorListener_1.FSHErrorListener(file);
        // @ts-ignore
        lexer.removeErrorListeners();
        // @ts-ignore
        lexer.addErrorListener(listener);
        // @ts-ignore
        const tokens = new antlr4_1.CommonTokenStream(lexer);
        const parser = new FSHParser_1.FSHParser(tokens);
        // @ts-ignore
        parser.removeErrorListeners();
        // @ts-ignore
        parser.addErrorListener(listener);
        // @ts-ignore
        parser.buildParseTrees = true;
        // @ts-ignore
        return parser.doc();
    }
}
exports.FSHImporter = FSHImporter;
//# sourceMappingURL=FSHImporter.js.map