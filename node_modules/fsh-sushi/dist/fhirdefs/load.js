"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("../errors");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const os_1 = __importDefault(require("os"));
const tar_1 = __importDefault(require("tar"));
const axios_1 = __importDefault(require("axios"));
const junk_1 = __importDefault(require("junk"));
const temp_1 = __importDefault(require("temp"));
const utils_1 = require("../utils");
const fhir_1 = require("fhir/fhir");
/**
 * Loads a dependency from user FHIR cache or from online
 * @param {string} packageName - The name of the package to load
 * @param {string} version - The version of the package to load
 * @param {FHIRDefinitions} FHIRDefs - The FHIRDefinitions to load the dependencies into
 * @param {string} cachePath - The path to load the package into
 * @returns {Promise<FHIRDefinitions>} the loaded FHIRDefs
 * @throws {PackageLoadError} when the desired package can't be loaded
 */
function loadDependency(packageName, version, FHIRDefs, cachePath = path_1.default.join(os_1.default.homedir(), '.fhir', 'packages')) {
    var _a, _b, _c;
    return __awaiter(this, void 0, void 0, function* () {
        let fullPackageName = `${packageName}#${version}`;
        let loadPath = path_1.default.join(cachePath, fullPackageName, 'package');
        let loadedPackage;
        // First, try to load the package from the local cache
        utils_1.logger.info(`Checking local cache for ${fullPackageName}...`);
        loadedPackage = loadFromPath(loadPath, fullPackageName, FHIRDefs);
        if (loadedPackage) {
            utils_1.logger.info(`Found ${fullPackageName} in local cache.`);
        }
        else {
            utils_1.logger.info(`Did not find ${fullPackageName} in local cache.`);
        }
        // When a dev package is not present locally, fall back to using the current version
        // as described here https://confluence.hl7.org/pages/viewpage.action?pageId=35718627#IGPublisherDocumentation-DependencyList
        if (version === 'dev' && !loadedPackage) {
            utils_1.logger.info(`Falling back to ${packageName}#current since ${fullPackageName} is not locally cached. To avoid this, add ${fullPackageName} to your local FHIR cache by building it locally with the HL7 FHIR IG Publisher.`);
            version = 'current';
            fullPackageName = `${packageName}#${version}`;
            loadPath = path_1.default.join(cachePath, fullPackageName, 'package');
            loadedPackage = loadFromPath(loadPath, fullPackageName, FHIRDefs);
        }
        let packageUrl;
        if (packageName.startsWith('hl7.fhir.r5.') && version === 'current') {
            packageUrl = `http://build.fhir.org/${packageName}.tgz`;
            // TODO: Figure out how to determine if the cached package is current
            // See: https://chat.fhir.org/#narrow/stream/179252-IG-creation/topic/Registry.20for.20FHIR.20Core.20packages.20.3E.204.2E0.2E1
            if (loadedPackage) {
                utils_1.logger.info(`Downloading ${fullPackageName} since SUSHI cannot determine if the version in the local cache is the most recent build.`);
            }
        }
        else if (version === 'current') {
            // Even if a local current package is loaded, we must still check that the local package date matches
            // the date on the most recent version on build.fhir.org. If the date does not match, we re-download to the cache
            const baseUrl = 'http://build.fhir.org/ig';
            const res = yield axios_1.default.get(`${baseUrl}/qas.json`);
            const qaData = res === null || res === void 0 ? void 0 : res.data;
            // Find matching packages and sort by date to get the most recent
            let newestPackage;
            if ((qaData === null || qaData === void 0 ? void 0 : qaData.length) > 0) {
                const matchingPackages = qaData.filter(p => p['package-id'] === packageName);
                newestPackage = matchingPackages.sort((p1, p2) => {
                    return Date.parse(p2['date']) - Date.parse(p1['date']);
                })[0];
            }
            if (newestPackage === null || newestPackage === void 0 ? void 0 : newestPackage.repo) {
                const [org, repo] = newestPackage.repo.split('/');
                const igUrl = `${baseUrl}/${org}/${repo}`;
                // get the package.manifest.json for the newest version of the package on build.fhir.org
                const manifest = yield axios_1.default.get(`${igUrl}/package.manifest.json`);
                let cachedPackageJSON;
                if (fs_extra_1.default.existsSync(path_1.default.join(loadPath, 'package.json'))) {
                    cachedPackageJSON = fs_extra_1.default.readJSONSync(path_1.default.join(loadPath, 'package.json'));
                }
                // if the date on the package.manifest.json does not match the date on the cached package
                // set the packageUrl to trigger a re-download of the package
                if (((_a = manifest === null || manifest === void 0 ? void 0 : manifest.data) === null || _a === void 0 ? void 0 : _a.date) !== (cachedPackageJSON === null || cachedPackageJSON === void 0 ? void 0 : cachedPackageJSON.date)) {
                    packageUrl = `${igUrl}/package.tgz`;
                    if (cachedPackageJSON) {
                        utils_1.logger.debug(`Cached package date for ${fullPackageName} (${formatDate(cachedPackageJSON.date)}) does not match last build date on build.fhir.org (${formatDate((_b = manifest === null || manifest === void 0 ? void 0 : manifest.data) === null || _b === void 0 ? void 0 : _b.date)})`);
                        utils_1.logger.info(`Cached package ${fullPackageName} is out of date and will be replaced by the more recent version found on build.fhir.org.`);
                    }
                }
                else {
                    utils_1.logger.debug(`Cached package date for ${fullPackageName} (${formatDate(cachedPackageJSON.date)}) matches last build date on build.fhir.org (${formatDate((_c = manifest === null || manifest === void 0 ? void 0 : manifest.data) === null || _c === void 0 ? void 0 : _c.date)}), so the cached package will be used`);
                }
            }
            else {
                throw new errors_1.CurrentPackageLoadError(fullPackageName);
            }
        }
        else if (!loadedPackage) {
            // If the package is not locally cached, and it is not a current or dev version, we attempt to get it
            // from packages.fhir.org or packages2.fhir.org
            if (packageName.startsWith('hl7.fhir.r5.')) {
                // Temporary.  See: https://chat.fhir.org/#narrow/stream/179252-IG-creation/topic/Registry.20for.20FHIR.20Core.20packages.20.3E.204.2E0.2E1
                packageUrl = `http://packages2.fhir.org/packages/${packageName}/${version}`;
            }
            else {
                packageUrl = `http://packages.fhir.org/${packageName}/${version}`;
            }
        }
        // If the packageUrl is set, we must download the package from that url, and extract it to our local cache
        if (packageUrl) {
            // Create a temporary file and write the package to there
            temp_1.default.track();
            const tempFile = temp_1.default.openSync();
            const targetDirectory = path_1.default.join(cachePath, fullPackageName);
            utils_1.logger.info(`Downloading ${fullPackageName}...`);
            const res = yield axios_1.default.get(packageUrl, {
                responseType: 'arraybuffer'
            });
            if (res === null || res === void 0 ? void 0 : res.data) {
                utils_1.logger.info(`Downloaded ${fullPackageName}`);
                fs_extra_1.default.ensureDirSync(targetDirectory);
                fs_extra_1.default.writeFileSync(tempFile.path, res.data);
                // Extract the package from that temporary file location
                tar_1.default.x({
                    cwd: targetDirectory,
                    file: tempFile.path,
                    sync: true,
                    strict: true
                });
                cleanCachedPackage(targetDirectory);
                // Now try to load again from the path
                loadedPackage = loadFromPath(loadPath, fullPackageName, FHIRDefs);
            }
            else {
                utils_1.logger.info(`Unable to download most current version of ${fullPackageName}`);
            }
        }
        if (!loadedPackage) {
            // If we fail again, then we couldn't get the package locally or from online
            throw new errors_1.PackageLoadError(fullPackageName);
        }
        utils_1.logger.info(`Loaded package ${fullPackageName}`);
        return FHIRDefs;
    });
}
exports.loadDependency = loadDependency;
/**
 * This function takes a package which contains contents at the same level as the "package" folder, and nests
 * all that content within the "package" folder.
 *
 * A package should have the format described here https://confluence.hl7.org/pages/viewpage.action?pageId=35718629#NPMPackageSpecification-Format
 * in which all contents are within the "package" folder. Some packages (ex US Core 3.1.0) have an incorrect format in which folders
 * are not sub-folders of "package", but are instead at the same level. The IG Publisher fixes these packages as described
 * https://chat.fhir.org/#narrow/stream/215610-shorthand/topic/dev.20dependencies, so SUSHI should as well.
 *
 * @param {string} packageDirectory - The directory containing the package
 */
function cleanCachedPackage(packageDirectory) {
    if (fs_extra_1.default.existsSync(path_1.default.join(packageDirectory, 'package'))) {
        fs_extra_1.default.readdirSync(packageDirectory)
            .filter(file => file !== 'package')
            .forEach(file => {
            fs_extra_1.default.renameSync(path_1.default.join(packageDirectory, file), path_1.default.join(packageDirectory, 'package', file));
        });
    }
}
exports.cleanCachedPackage = cleanCachedPackage;
/**
 * Loads custom resources defined in ig-data into FHIRDefs
 * @param {string} resourceDir - The path to the directory containing the resource subdirs
 * @param {FHIRDefinitions} defs - The FHIRDefinitions object to load definitions into
 */
function loadCustomResources(resourceDir, defs) {
    // Similar code for loading custom resources exists in IGExporter.ts addPredefinedResources()
    const pathEnds = [
        'capabilities',
        'extensions',
        'models',
        'operations',
        'profiles',
        'resources',
        'vocabulary',
        'examples'
    ];
    const converter = new fhir_1.Fhir();
    let invalidFileCount = 0;
    for (const pathEnd of pathEnds) {
        let foundSpreadsheets = false;
        const dirPath = path_1.default.join(resourceDir, pathEnd);
        if (fs_extra_1.default.existsSync(dirPath)) {
            const files = fs_extra_1.default.readdirSync(dirPath);
            for (const file of files) {
                let resourceJSON;
                try {
                    if (junk_1.default.is(file)) {
                        // Ignore "junk" files created by the OS, like .DS_Store on macOS and Thumbs.db on Windows
                        continue;
                    }
                    else if (file.endsWith('.json')) {
                        resourceJSON = fs_extra_1.default.readJSONSync(path_1.default.join(dirPath, file));
                    }
                    else if (file.endsWith('-spreadsheet.xml')) {
                        foundSpreadsheets = true;
                        continue;
                    }
                    else if (file.endsWith('xml')) {
                        const xml = fs_extra_1.default.readFileSync(path_1.default.join(dirPath, file)).toString();
                        if (/<\?mso-application progid="Excel\.Sheet"\?>/m.test(xml)) {
                            foundSpreadsheets = true;
                            continue;
                        }
                        resourceJSON = converter.xmlToObj(xml);
                    }
                    else {
                        invalidFileCount++;
                        continue;
                    }
                }
                catch (e) {
                    utils_1.logger.error(`Loading ${file} failed with the following error:\n${e.message}`);
                    continue;
                }
                // All resources are added to the predefined map, so that this map can later be used to
                // access predefined resources in the IG Exporter
                defs.addPredefinedResource(file, resourceJSON);
                if (pathEnd !== 'examples') {
                    // add() will only add resources of resourceType:
                    // StructureDefinition, ValueSet, CodeSystem, or ImplementationGuide
                    defs.add(resourceJSON);
                }
            }
        }
        if (foundSpreadsheets) {
            utils_1.logger.info(`Found spreadsheets in directory ${dirPath}. SUSHI does not support spreadsheets, so any resources in the spreadsheets will be ignored.`);
        }
    }
    if (invalidFileCount > 0) {
        utils_1.logger.info(invalidFileCount > 1
            ? `Found ${invalidFileCount} files in input/* resource folders that were neither XML nor JSON. These files were not processed as resources by SUSHI.`
            : `Found ${invalidFileCount} file in an input/* resource folder that was neither XML nor JSON. This file was not processed as a resource by SUSHI.`);
    }
}
exports.loadCustomResources = loadCustomResources;
/**
 * Loads a set of JSON files at targetPath into FHIRDefs
 * @param {string} targetPath - The path to the directory containing the JSON definitions
 * @param {string} targetPackage - The name of the package we are trying to load
 * @param {FHIRDefinitions} FHIRDefs - The FHIRDefinitions object to load defs into
 * @returns {string} the name of the loaded package if successful
 */
function loadFromPath(targetPath, targetPackage, FHIRDefs) {
    if (FHIRDefs.packages.indexOf(targetPackage) < 0) {
        const originalSize = FHIRDefs.size();
        if (fs_extra_1.default.existsSync(targetPath)) {
            const files = fs_extra_1.default.readdirSync(targetPath);
            for (const file of files) {
                if (file.endsWith('.json')) {
                    const def = JSON.parse(fs_extra_1.default.readFileSync(path_1.default.join(targetPath, file), 'utf-8').trim());
                    FHIRDefs.add(def);
                }
            }
        }
        // If we did successfully load definitions, mark this package as loaded
        if (FHIRDefs.size() > originalSize) {
            FHIRDefs.packages.push(targetPackage);
            return targetPackage;
        }
    }
    else {
        // If the package has already been loaded, just return the targetPackage string
        return targetPackage;
    }
}
exports.loadFromPath = loadFromPath;
/**
 * Takes a date in format YYYYMMDDHHmmss and converts to YYYY-MM-DDTHH:mm:ss
 * @param {string} date - The date to format
 * @returns {string} the formatted date
 */
function formatDate(date) {
    return date
        ? date.replace(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/, '$1-$2-$3T$4:$5:$6')
        : '';
}
//# sourceMappingURL=load.js.map