"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const common_1 = require("./common");
const utils_1 = require("../utils");
/**
 * A class representing a FHIR Instance.
 *
 * The defined properties on InstanceDefinition are relatively simple due to the fact that each FHIR resource will
 * be setting different properties based on their own definitions.
 */
class InstanceDefinition {
    constructor() {
        this._instanceMeta = {};
    }
    /**
     * Get the file name for serializing to disk.
     * @returns {string} the filename
     */
    getFileName() {
        var _a;
        return `${this.resourceType}-${(_a = this.id) !== null && _a !== void 0 ? _a : this._instanceMeta.name}.json`;
    }
    toJSON() {
        const orderedKeys = ['resourceType', '_resourceType', 'id', '_id', 'meta', '_meta'].filter(key => this[key] != null);
        // _instanceMeta is only needed for lookup and IG config - not a FHIR property
        const additionalKeys = lodash_1.difference(Object.keys(this), [...orderedKeys, '_instanceMeta']);
        return orderedCloneDeep(this, [...orderedKeys, ...additionalKeys]);
    }
    static fromJSON(json) {
        const instanceDefinition = new InstanceDefinition();
        Object.keys(json).forEach(key => {
            instanceDefinition[key] = json[key];
        });
        // Default the meta name to the id
        if (json.id != null) {
            instanceDefinition._instanceMeta.name = json.id;
        }
        return instanceDefinition;
    }
}
exports.InstanceDefinition = InstanceDefinition;
/**
 * Make a deep clone recursively, adding properties in the order expected for exported JSON.
 * If a list of keys is provided, use those properties from the input.
 * Otherwise, use all properties from the input.
 *
 * @param input - the value to clone
 * @param keys - optionally, the properties of the value to include in the clone
 * @returns {any} - a clone of the input, with reordered properties
 */
function orderedCloneDeep(input, keys = Object.keys(input)) {
    // non-objects should be cloned normally
    // arrays should get a recursive call on their elements, but don't need reordering
    if (typeof input !== 'object') {
        return lodash_1.cloneDeep(input);
    }
    else if (Array.isArray(input)) {
        return input.map(element => orderedCloneDeep(element));
    }
    else {
        const underscoreKeys = lodash_1.remove(keys, key => key.startsWith('_'));
        const orderedKeys = [];
        const result = {};
        keys.forEach(key => {
            orderedKeys.push(key);
            if (underscoreKeys.includes(`_${key}`)) {
                orderedKeys.push(`_${key}`);
                lodash_1.pull(underscoreKeys, `_${key}`);
            }
        });
        underscoreKeys.forEach(key => {
            orderedKeys.push(key);
        });
        orderedKeys.forEach(key => {
            result[key] = orderedCloneDeep(input[key]);
        });
        return result;
    }
}
utils_1.applyMixins(InstanceDefinition, [common_1.HasId]);
//# sourceMappingURL=InstanceDefinition.js.map