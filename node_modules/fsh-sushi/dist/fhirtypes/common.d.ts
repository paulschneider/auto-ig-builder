import { StructureDefinition, PathPart, ElementDefinition, InstanceDefinition, ValueSet, CodeSystem } from '.';
import { AssignmentRule, CaretValueRule } from '../fshtypes/rules';
import { Instance, SourceInfo, Profile, Extension, RuleSet, FshValueSet, FshCodeSystem, Mapping } from '../fshtypes';
import { FSHTank } from '../import';
import { Fishable } from '../utils/Fishable';
import { FHIRId } from './primitiveTypes';
export declare function splitOnPathPeriods(path: string): string[];
/**
 * This function sets an instance property of an SD or ED if possible
 * @param {StructureDefinition | ElementDefinition} - The instance to assign a value on
 * @param {string} path - The path to assign a value at
 * @param {any} value - The value to assign
 * @param {Fishable} fisher - A fishable implementation for finding definitions and metadata
 */
export declare function setPropertyOnDefinitionInstance(instance: StructureDefinition | ElementDefinition, path: string, value: any, fisher: Fishable): void;
export declare function setImpliedPropertiesOnInstance(instanceDef: StructureDefinition | ElementDefinition | InstanceDefinition, instanceOfStructureDefinition: StructureDefinition, paths: string[], fisher: Fishable): void;
export declare function setPropertyOnInstance(instance: StructureDefinition | ElementDefinition | InstanceDefinition | ValueSet | CodeSystem, pathParts: PathPart[], assignedValue: any): void;
/**
 * Tests to see if the last bracket in a PathPart is a non-negative int, and if so returns it
 * @param {PathPart} pathPart - The part of the path to test
 * @returns {number} The index if it exists and is non-negative, otherwise undefined
 *
 */
export declare function getArrayIndex(pathPart: PathPart): number;
/**
 * Replaces references to instances by the correct path to that instance.
 * Replaces references to local code systems by the url for that code system.
 * @param {AssignmentRule} rule - The rule to replace references on
 * @param {FSHTank} tank - The tank holding the instances and code systems
 * @param {Fishable} fisher - A fishable implementation for finding definitions and metadata
 * @returns {AssignmentRule} a clone of the rule if replacing is done, otherwise the original rule
 */
export declare function replaceReferences<T extends AssignmentRule | CaretValueRule>(rule: T, tank: FSHTank, fisher: Fishable): T;
/**
 * Returns the sliceName for a set of pathParts
 * @param {PathPart} pathPart - The part of the path to get a sliceName for
 * @returns {string} The slicenName for the path part
 */
export declare function getSliceName(pathPart: PathPart): string;
/**
 * Replaces fields in an object that match a certain condition
 * @param { {[key: string]: any} } object - The object to replace fields on
 * @param {(object: { [key: string]: any }, prop: string) => boolean} matchFn - The function to match with
 * @param {(object: { [key: string]: any }, prop: string) => void} replaceFn - The function to replace with
 * @param {string => boolean} skipFn - A function that returns true if a property should not be traversed
 */
export declare function replaceField(object: {
    [key: string]: any;
}, matchFn: (object: {
    [key: string]: any;
}, prop: string) => boolean, replaceFn: (object: {
    [key: string]: any;
}, prop: string) => void, skipFn: (prop: string) => boolean): void;
/**
 * Cleans up temporary properties that were added to the resource definition during processing
 * @param {StructureDefinition | InstanceDefinition} resourceDef - The resource definition to clean
 * @param {string => boolean} skipFn - A function that returns true if a property should not be traversed
 */
export declare function cleanResource(resourceDef: StructureDefinition | InstanceDefinition, skipFn?: (prop: string) => boolean): void;
/**
 * Adds Mixin rules onto a Profile, Extension, or Instance
 * @param {Profile | Extension | Instance} fshDefinition - The definition to apply mixin rules on
 * @param {FSHTank} tank - The FSHTank containing the fshDefinition
 */
export declare function applyMixinRules(fshDefinition: Profile | Extension | Instance, tank: FSHTank): void;
/**
 * Adds insert rules onto a Profile, Extension, or Instance
 * @param fshDefinition - The definition to apply rules on
 * @param tank - The FSHTank containing the fshDefinition
 */
export declare function applyInsertRules(fshDefinition: Profile | Extension | Instance | FshValueSet | FshCodeSystem | Mapping | RuleSet, tank: FSHTank, seenRuleSets?: string[]): void;
/**
 * Finds all FSH paths implied by the FSH path pointing at element. Paths are implied by array elements.
 * For example, if foo is 2..* and bar is 2..*, and bar has a assigned value of "hello", then the rule
 * "foo[0].baz = "hey" " implies the following:
 * foo[0].baz = "hey"
 * foo[0].bar[0] = "hello"
 * foo[1].bar[0] = "hello"
 * foo[0].bar[1] = "hello"
 * foo[1].bar[1] = "hello"
 * @param {ElementDefinition} element - The element that the path corresponds to
 * @param {path} string - The FSH path to the element
 * @returns {string[]} - All implied FSH paths by the path pointing to element
 */
export declare function getAllImpliedPaths(element: ElementDefinition, path: string): string[];
/**
 * Tests if resourceType is a valid FHIR resource that is a subtype of type. This is the case
 * if type is Resource, or if type is DomainResource and resourceType is one of the resources
 * that inherits from DomainResource, or if type is equal to resourceType.
 * @param {string} resourceType - The resourceType to test inheritance of
 * @param {string} type - The original type being inherited from
 * @param {Fishable} fisher - A fisher for finding FHIR definitions
 * @param {boolean} allowProfile - True if profiles of inherited resource should be allowed
 * @returns {boolean} true if resourceType is a valid sub-type of type, false otherwise
 */
export declare function isInheritedResource(resourceType: string, type: string, fisher: Fishable, allowProfile?: boolean): boolean;
/**
 * Determines the formal FHIR URL to use to refer to this entity (for example when fishing).
 * If a caret value rule has been applied to the entity's url, use the value specified in that
 * rule. Otherwise, use the default url based on the configured canonical url.
 *
 * @param fshDefinition - The FSH definition that the returned URL refers to
 * @param canonical - The canonical URL for the FSH project
 * @returns {string} - The URL to use to refer to the FHIR entity
 */
export declare function getUrlFromFshDefinition(fshDefinition: Profile | Extension | FshValueSet | FshCodeSystem, canonical: string): string;
export declare class HasName {
    name?: string;
    /**
     * Set the name and check if it matches the regular expression specified
     * in the invariant for "name" properties. A name must be between 1 and 255 characters long,
     * begin with an uppercase letter, and contain only uppercase letter, lowercase letter,
     * numeral, and '_' characters.
     * If the string does not match, log an error.
     *
     * @see {@link http://hl7.org/fhir/R4/structuredefinition-definitions.html#StructureDefinition.name}
     * @see {@link http://hl7.org/fhir/R4/valueset-definitions.html#ValueSet.name}
     * @see {@link http://hl7.org/fhir/R4/codesystem-definitions.html#CodeSystem.name}
     * @param {string} name - The name to check against the name invariant
     * @param {SourceInfo} sourceInfo - The FSH file and location that specified the name
     */
    setName(name: string, sourceInfo: SourceInfo): void;
}
export declare class HasId {
    id?: FHIRId;
    /**
     * Set the id and check if it matches the regular expression specified
     * in the definition of the "id" type.
     * If the FHIRId does not match, log an error.
     *
     * @param id - The new id to set
     * @param sourceInfo - The FSH file and location that specified the id
     */
    setId(id: FHIRId, sourceInfo: SourceInfo): void;
    /**
     * Check if the current id matches the regular expression specified
     * in the definition of the "id" type.
     * If the FHIRId does not match, log an error.
     * If the id is a valid name, sanitize it to a valid id and log a warning
     *
     * @param sourceInfo - The FSH file and location that specified the id
     */
    validateId(sourceInfo: SourceInfo): void;
}
