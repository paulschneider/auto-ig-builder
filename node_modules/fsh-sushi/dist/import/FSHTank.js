"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fshtypes_1 = require("../fshtypes");
const flatMap_1 = __importDefault(require("lodash/flatMap"));
const Fishable_1 = require("../utils/Fishable");
const common_1 = require("../fhirtypes/common");
class FSHTank {
    constructor(docs, config) {
        this.docs = docs;
        this.config = config;
    }
    /**
     * Gets all profiles in the tank
     * @returns {Profile[]}
     */
    getAllProfiles() {
        return flatMap_1.default(this.docs, doc => Array.from(doc.profiles.values()));
    }
    /**
     * Gets all extensions in the tank
     * @returns {Extension[]}
     */
    getAllExtensions() {
        return flatMap_1.default(this.docs, doc => Array.from(doc.extensions.values()));
    }
    /**
     * Gets all instances in the tank
     * @returns {Instance[]}
     */
    getAllInstances() {
        return flatMap_1.default(this.docs, doc => Array.from(doc.instances.values()));
    }
    /**
     * Gets all structure definitions (profiles and extensions) in the tank
     * @returns {(Profile | Extension)[]}
     */
    getAllStructureDefinitions() {
        return [...this.getAllProfiles(), ...this.getAllExtensions()];
    }
    /**
     * Gets all value sets in the tank
     * @returns {FshValueSet[]}
     */
    getAllValueSets() {
        return flatMap_1.default(this.docs, doc => Array.from(doc.valueSets.values()));
    }
    /**
     * Gets all code systems in the tank
     * @returns {FshCodeSystem[]}
     */
    getAllCodeSystems() {
        return flatMap_1.default(this.docs, doc => Array.from(doc.codeSystems.values()));
    }
    /**
     * Gets all invariants in the tank
     * @returns {Invariant[]}
     */
    getAllInvariants() {
        return flatMap_1.default(this.docs, doc => Array.from(doc.invariants.values()));
    }
    /**
     * Gets all ruleSets in the tank
     * @returns {RuleSet[]}
     */
    getAllRuleSets() {
        return flatMap_1.default(this.docs, doc => Array.from(doc.ruleSets.values()));
    }
    /**
     * Gets all Mappings in the tank
     * @returns {Mapping[]}
     */
    getAllMappings() {
        return flatMap_1.default(this.docs, doc => Array.from(doc.mappings.values()));
    }
    /**
     * Finds the alias in the tank, if it exists
     * @param {string} name - The name of the alias we're looking for
     * @returns {string | undefined}
     */
    resolveAlias(name) {
        for (const doc of this.docs) {
            const foundAlias = doc.aliases.get(name);
            if (foundAlias)
                return foundAlias;
        }
        return undefined;
    }
    fish(item, ...types) {
        var _a;
        // Resolve alias if necessary
        item = (_a = this.resolveAlias(item)) !== null && _a !== void 0 ? _a : item;
        // No types passed in means to search ALL supported types
        if (types.length === 0) {
            types = [
                Fishable_1.Type.Profile,
                Fishable_1.Type.Extension,
                Fishable_1.Type.ValueSet,
                Fishable_1.Type.CodeSystem,
                Fishable_1.Type.Instance,
                Fishable_1.Type.Invariant,
                Fishable_1.Type.RuleSet,
                Fishable_1.Type.Mapping
            ];
        }
        for (const t of types) {
            let result;
            switch (t) {
                case Fishable_1.Type.Profile:
                    result = this.getAllProfiles().find(p => p.name === item ||
                        p.id === item ||
                        common_1.getUrlFromFshDefinition(p, this.config.canonical) === item);
                    break;
                case Fishable_1.Type.Extension:
                    result = this.getAllExtensions().find(e => e.name === item ||
                        e.id === item ||
                        common_1.getUrlFromFshDefinition(e, this.config.canonical) === item);
                    break;
                case Fishable_1.Type.ValueSet:
                    result = this.getAllValueSets().find(vs => vs.name === item ||
                        vs.id === item ||
                        common_1.getUrlFromFshDefinition(vs, this.config.canonical) === item);
                    break;
                case Fishable_1.Type.CodeSystem:
                    result = this.getAllCodeSystems().find(cs => cs.name === item ||
                        cs.id === item ||
                        common_1.getUrlFromFshDefinition(cs, this.config.canonical) === item);
                    break;
                case Fishable_1.Type.Instance:
                    result = this.getAllInstances().find(i => i.name === item || i.id === item);
                    break;
                case Fishable_1.Type.Invariant:
                    result = this.getAllInvariants().find(i => i.name === item);
                    break;
                case Fishable_1.Type.RuleSet:
                    result = this.getAllRuleSets().find(r => r.name === item);
                    break;
                case Fishable_1.Type.Mapping:
                    result = this.getAllMappings().find(m => m.name === item);
                    break;
                case Fishable_1.Type.Resource:
                case Fishable_1.Type.Type:
                default:
                    // Tank doesn't support these types
                    break;
            }
            if (result != null) {
                return result;
            }
        }
        // No match, return undefined
        return;
    }
    fishForAppliedRuleSet(item) {
        for (const doc of this.docs) {
            const ruleSet = doc.appliedRuleSets.get(item);
            if (ruleSet) {
                return ruleSet;
            }
        }
    }
    fishForMetadata(item, ...types) {
        const result = this.fish(item, ...types);
        if (result) {
            const meta = {
                id: result.id,
                name: result.name
            };
            if (result instanceof fshtypes_1.Profile || result instanceof fshtypes_1.Extension) {
                meta.url = common_1.getUrlFromFshDefinition(result, this.config.canonical);
                meta.parent = result.parent;
            }
            else if (result instanceof fshtypes_1.FshValueSet || result instanceof fshtypes_1.FshCodeSystem) {
                meta.url = common_1.getUrlFromFshDefinition(result, this.config.canonical);
            }
            else if (result instanceof fshtypes_1.Instance) {
                meta.instanceUsage = result.usage;
            }
            return meta;
        }
        return;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    fishForFHIR(item, ...types) {
        // the FSHTank cannot return FHIR definitions, but we define this function
        // in order to implement the Fishable interface
    }
}
exports.FSHTank = FSHTank;
//# sourceMappingURL=FSHTank.js.map