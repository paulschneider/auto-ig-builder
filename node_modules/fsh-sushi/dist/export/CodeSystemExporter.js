"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fhirtypes_1 = require("../fhirtypes");
const common_1 = require("../fhirtypes/common");
const rules_1 = require("../fshtypes/rules");
const FSHLogger_1 = require("../utils/FSHLogger");
const utils_1 = require("../utils");
class CodeSystemExporter {
    constructor(tank, pkg, fisher) {
        this.tank = tank;
        this.pkg = pkg;
        this.fisher = fisher;
    }
    setMetadata(codeSystem, fshDefinition) {
        codeSystem.setName(fshDefinition.name, fshDefinition.sourceInfo);
        codeSystem.setId(fshDefinition.id, fshDefinition.sourceInfo);
        if (fshDefinition.title)
            codeSystem.title = fshDefinition.title;
        if (fshDefinition.description)
            codeSystem.description = fshDefinition.description;
        // Version is set to value provided in config, will be overriden if reset by rules
        codeSystem.version = this.tank.config.version;
        codeSystem.url = `${this.tank.config.canonical}/CodeSystem/${codeSystem.id}`;
    }
    setConcepts(codeSystem, concepts) {
        if (concepts.length > 0) {
            codeSystem.concept = concepts.map(concept => {
                const codeSystemConcept = { code: concept.code };
                if (concept.display)
                    codeSystemConcept.display = concept.display;
                if (concept.definition)
                    codeSystemConcept.definition = concept.definition;
                return codeSystemConcept;
            });
        }
    }
    setCaretRules(codeSystem, rules) {
        const csStructureDefinition = fhirtypes_1.StructureDefinition.fromJSON(this.fisher.fishForFHIR('CodeSystem', utils_1.Type.Resource));
        utils_1.resolveSoftIndexing(rules);
        for (const rule of rules) {
            try {
                const { assignedValue, pathParts } = csStructureDefinition.validateValueAtPath(rule.caretPath, rule.value, this.fisher);
                common_1.setPropertyOnInstance(codeSystem, pathParts, assignedValue);
            }
            catch (e) {
                FSHLogger_1.logger.error(e.message, rule.sourceInfo);
            }
        }
    }
    updateCount(codeSystem, fshDefinition) {
        var _a, _b;
        // We can only derive a true count if the content is #complete
        if (codeSystem.content === 'complete') {
            const actualCount = (_a = codeSystem.concept) === null || _a === void 0 ? void 0 : _a.length;
            if (codeSystem.count == null && actualCount != null) {
                codeSystem.count = actualCount;
            }
            else if (codeSystem.count !== actualCount) {
                const countRule = fshDefinition.rules.find(r => r instanceof rules_1.CaretValueRule && r.caretPath === 'count');
                const sourceInfo = (_b = countRule === null || countRule === void 0 ? void 0 : countRule.sourceInfo) !== null && _b !== void 0 ? _b : fshDefinition.sourceInfo;
                FSHLogger_1.logger.warn(`The user-specified ^count (${codeSystem.count}) does not match the specified number of concepts ` +
                    `(${actualCount !== null && actualCount !== void 0 ? actualCount : 0}). If this is not a "complete" CodeSystem, set the ^content property to the appropriate ` +
                    'value; otherwise fix or remove the ^count.', sourceInfo);
            }
        }
    }
    exportCodeSystem(fshDefinition) {
        if (this.pkg.codeSystems.some(cs => cs.name === fshDefinition.name)) {
            return;
        }
        const codeSystem = new fhirtypes_1.CodeSystem();
        this.setMetadata(codeSystem, fshDefinition);
        // fshDefinition.rules may include insert rules, which must be expanded before applying other rules
        common_1.applyInsertRules(fshDefinition, this.tank);
        this.setCaretRules(codeSystem, fshDefinition.rules.filter(rule => rule instanceof rules_1.CaretValueRule));
        this.setConcepts(codeSystem, fshDefinition.rules.filter(rule => rule instanceof rules_1.ConceptRule));
        // check for another code system with the same id
        // see https://www.hl7.org/fhir/resource.html#id
        if (this.pkg.codeSystems.some(cs => codeSystem.id === cs.id)) {
            FSHLogger_1.logger.error(`Multiple code systems with id ${codeSystem.id}. Each code system must have a unique id.`, fshDefinition.sourceInfo);
        }
        this.updateCount(codeSystem, fshDefinition);
        this.pkg.codeSystems.push(codeSystem);
        return codeSystem;
    }
    export() {
        const codeSystems = this.tank.getAllCodeSystems();
        for (const cs of codeSystems) {
            try {
                this.exportCodeSystem(cs);
            }
            catch (e) {
                FSHLogger_1.logger.error(e.message, cs.sourceInfo);
            }
        }
        if (codeSystems.length > 0) {
            FSHLogger_1.logger.info(`Converted ${codeSystems.length} FHIR CodeSystems.`);
        }
        return this.pkg;
    }
}
exports.CodeSystemExporter = CodeSystemExporter;
//# sourceMappingURL=CodeSystemExporter.js.map